<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>cheatsheet</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>cheatsheet</h1><br/><br /> From: <a href="https://github.com/LeCoupa/awesome-cheatsheets/blob/master/languages/bash.sh">https://github.com/LeCoupa/awesome-cheatsheets/blob/master/languages/bash.sh</a><br /><br />#!/bin/bash<br />##############################################################################<br /># SHORTCUTS and HISTORY<br />##############################################################################<br /><br />CTRL+A  # move to beginning of line<br />CTRL+B  # moves backward one character<br />CTRL+C  # halts the current command<br />CTRL+D  # deletes one character backward or logs out of current session, similar to exit<br />CTRL+E  # moves to end of line<br />CTRL+F  # moves forward one character<br />CTRL+G  # aborts the current editing command and ring the terminal bell<br />CTRL+H  # deletes one character under cursor (same as DELETE)<br />CTRL+J  # same as RETURN<br />CTRL+K  # deletes (kill) forward to end of line<br />CTRL+L  # clears screen and redisplay the line<br />CTRL+M  # same as RETURN<br />CTRL+N  # next line in command history<br />CTRL+O  # same as RETURN, then displays next line in history file<br />CTRL+P  # previous line in command history<br />CTRL+R  # searches backward<br />CTRL+S  # searches forward<br />CTRL+T  # transposes two characters<br />CTRL+U  # kills backward from point to the beginning of line<br />CTRL+V  # makes the next character typed verbatim<br />CTRL+W  # kills the word behind the cursor<br />CTRL+X  # lists the possible filename completions of the current word<br />CTRL+Y  # retrieves (yank) last item killed<br />CTRL+Z  # stops the current command, resume with fg in the foreground or bg in the background<br /><br />ALT+B   # moves backward one word<br />ALT+D   # deletes next word<br />ALT+F   # moves forward one word<br />ALT+H   # deletes one character backward<br />ALT+T   # transposes two words<br />ALT+.   # pastes last word from the last command. Pressing it repeatedly traverses through command history.<br />ALT+U   # capitalizes every character from the current cursor position to the end of the word<br />ALT+L   # uncapitalizes every character from the current cursor position to the end of the word<br />ALT+C   # capitalizes the letter under the cursor. The cursor then moves to the end of the word.<br />ALT+R   # reverts any changes to a command you’ve pulled from your history if you’ve edited it.<br /><br />BACKSPACE  # deletes one character backward<br />DELETE     # deletes one character under cursor<br /><br />history   # shows command line history<br />!!        # repeats the last command<br />!&lt;n&gt;      # refers to command line &#39;n&#39;<br />!&lt;string&gt; # refers to command starting with &#39;string&#39;<br /><br />exit      # logs out of current session<br /><br /><br />##############################################################################<br /># BASH BASICS<br />##############################################################################<br /><br />env                 # displays all environment variables<br /><br />echo $SHELL         # displays the shell you&#39;re using<br />echo $BASH_VERSION  # displays bash version<br /><br />bash                # if you want to use bash (type exit to go back to your previously opened shell)<br />whereis bash        # locates the binary, source and manual-page for a command<br />which bash          # finds out which program is executed as &#39;bash&#39; (default: /bin/bash, can change across environments)<br /><br />clear               # clears content on window (hide displayed lines)<br /><br /><br />##############################################################################<br /># FILE COMMANDS<br />##############################################################################<br /><br /><br />ls                            # lists your files in current directory, ls &lt;dir&gt; to print files in a specific directory<br />ls -l                         # lists your files in &#39;long format&#39;, which contains the exact size of the file, who owns the file and who has the right to look at it, and when it was last modified<br />ls -a                         # lists all files in &#39;long format&#39;, including hidden files (name beginning with &#39;.&#39;)<br />ln -s &lt;filename&gt; &lt;link&gt;       # creates symbolic link to file<br />touch &lt;filename&gt;              # creates or updates (edit) your file<br />cat &lt;filename&gt;                # prints file raw content (will not be interpreted)<br />any_command &gt; &lt;filename&gt;      # &#39;&gt;&#39; is used to perform redirections, it will set any_command&#39;s stdout to file instead of &quot;real stdout&quot; (generally /dev/stdout)<br />more &lt;filename&gt;               # shows the first part of a file (move with space and type q to quit)<br />head &lt;filename&gt;               # outputs the first lines of file (default: 10 lines)<br />tail &lt;filename&gt;               # outputs the last lines of file (useful with -f option) (default: 10 lines)<br />vim &lt;filename&gt;                # opens a file in VIM (VI iMproved) text editor, will create it if it doesn&#39;t exist<br />mv &lt;filename1&gt; &lt;dest&gt;         # moves a file to destination, behavior will change based on &#39;dest&#39; type (dir: file is placed into dir; file: file will replace dest (tip: useful for renaming))<br />cp &lt;filename1&gt; &lt;dest&gt;         # copies a file<br />rm &lt;filename&gt;                 # removes a file<br />find . -name &lt;name&gt; &lt;type&gt;    # searches for a file or a directory in the current directory and all its sub-directories by its name<br />diff &lt;filename1&gt; &lt;filename2&gt;  # compares files, and shows where they differ<br />wc &lt;filename&gt;                 # tells you how many lines, words and characters there are in a file. Use -lwc (lines, word, character) to ouput only 1 of those informations<br />sort &lt;filename&gt;               # sorts the contents of a text file line by line in alphabetical order, use -n for numeric sort and -r for reversing order.<br />sort -t -k &lt;filename&gt;         # sorts the contents on specific sort key field starting from 1, using the field separator t.<br />chmod -options &lt;filename&gt;     # lets you change the read, write, and execute permissions on your files (more infos: SUID, GUID)<br />gzip &lt;filename&gt;               # compresses files using gzip algorithm<br />gunzip &lt;filename&gt;             # uncompresses files compressed by gzip<br />gzcat &lt;filename&gt;              # lets you look at gzipped file without actually having to gunzip it<br />lpr &lt;filename&gt;                # prints the file<br />lpq                           # checks out the printer queue<br />lprm &lt;jobnumber&gt;              # removes something from the printer queue<br />genscript                     # converts plain text files into postscript for printing and gives you some options for formatting<br />dvips &lt;filename&gt;              # prints .dvi files (i.e. files produced by LaTeX)<br />grep &lt;pattern&gt; &lt;filenames&gt;    # looks for the string in the files<br />grep -r &lt;pattern&gt; &lt;dir&gt;       # search recursively for pattern in directory<br />head -n file_name | tail +n   # Print nth line from file.<br />head -y lines.txt | tail +x   # want to display all the lines from x to y. This includes the xth and yth lines.<br /><br /><br />##############################################################################<br /># DIRECTORY COMMANDS<br />##############################################################################<br /><br /><br />mkdir &lt;dirname&gt;               # makes a new directory<br />rmdir &lt;dirname&gt;               # remove an empty directory<br />rmdir -rf &lt;dirname&gt;           # remove a non-empty directory<br />mv &lt;dir1&gt; &lt;dir2&gt;              # rename a directory from &lt;dir1&gt; to &lt;dir2&gt;<br />cd                            # changes to home<br />cd ..                         # changes to the parent directory<br />cd &lt;dirname&gt;                  # changes directory<br />cp -r &lt;dir1&gt; &lt;dir2&gt;           # copy &lt;dir1&gt; into &lt;dir2&gt; including sub-directories<br />pwd                           # tells you where you currently are<br />cd ~                          # changes to home.<br /><br />##############################################################################<br /># SSH, SYSTEM INFO &amp; NETWORK COMMANDS<br />##############################################################################<br /><br /><br />ssh user@host            # connects to host as user<br />ssh -p &lt;port&gt; user@host  # connects to host on specified port as user<br />ssh-copy-id user@host    # adds your ssh key to host for user to enable a keyed or passwordless login<br /><br />whoami                   # returns your username<br />passwd                   # lets you change your password<br />quota -v                 # shows what your disk quota is<br />date                     # shows the current date and time<br />cal                      # shows the month&#39;s calendar<br />uptime                   # shows current uptime<br />w                        # displays whois online<br />finger &lt;user&gt;            # displays information about user<br />uname -a                 # shows kernel information<br />man &lt;command&gt;            # shows the manual for specified command<br />df                       # shows disk usage<br />du &lt;filename&gt;            # shows the disk usage of the files and directories in filename (du -s give only a total)<br />last &lt;yourUsername&gt;      # lists your last logins<br />ps -u yourusername       # lists your processes<br />kill &lt;PID&gt;               # kills the processes with the ID you gave<br />killall &lt;processname&gt;    # kill all processes with the name<br />top                      # displays your currently active processes<br />lsof                     # lists open files<br />bg                       # lists stopped or background jobs ; resume a stopped job in the background<br />fg                       # brings the most recent job in the foreground<br />fg &lt;job&gt;                 # brings job to the foreground<br /><br />ping &lt;host&gt;              # pings host and outputs results<br />whois &lt;domain&gt;           # gets whois information for domain<br />dig &lt;domain&gt;             # gets DNS information for domain<br />dig -x &lt;host&gt;            # reverses lookup host<br />wget &lt;file&gt;              # downloads file<br /><br /><br />##############################################################################<br /># VARIABLES<br />##############################################################################<br /><br /><br />varname=value                # defines a variable<br />varname=value command        # defines a variable to be in the environment of a particular subprocess<br />echo $varname                # checks a variable&#39;s value<br />echo $$                      # prints process ID of the current shell<br />echo $!                      # prints process ID of the most recently invoked background job<br />echo $?                      # displays the exit status of the last command<br />read &lt;varname&gt;               # reads a string from the input and assigns it to a variable <br />let &lt;varname&gt; = &lt;equation&gt;   # performs mathematical calculation using operators like +, -, *, /, %<br />export VARNAME=value         # defines an environment variable (will be available in subprocesses)<br /><br />array[0]=valA                # how to define an array<br />array[1]=valB<br />array[2]=valC<br />array=([2]=valC [0]=valA [1]=valB)  # another way<br />array=(valA valB valC)              # and another<br /><br />${array[i]}                  # displays array&#39;s value for this index. If no index is supplied, array element 0 is assumed<br />${#array[i]}                 # to find out the length of any element in the array<br />${#array[@]}                 # to find out how many values there are in the array<br /><br />declare -a                   # the variables are treated as arrays<br />declare -f                   # uses function names only<br />declare -F                   # displays function names without definitions<br />declare -i                   # the variables are treated as integers<br />declare -r                   # makes the variables read-only<br />declare -x                   # marks the variables for export via the environment<br /><br />${varname:-word}             # if varname exists and isn&#39;t null, return its value; otherwise return word<br />${varname:=word}             # if varname exists and isn&#39;t null, return its value; otherwise set it word and then return its value<br />${varname:?message}          # if varname exists and isn&#39;t null, return its value; otherwise print varname, followed by message and abort the current command or script<br />${varname:+word}             # if varname exists and isn&#39;t null, return word; otherwise return null<br />${varname:offset:length}     # performs substring expansion. It returns the substring of $varname starting at offset and up to length characters<br /><br />${variable#pattern}          # if the pattern matches the beginning of the variable&#39;s value, delete the shortest part that matches and return the rest<br />${variable##pattern}         # if the pattern matches the beginning of the variable&#39;s value, delete the longest part that matches and return the rest<br />${variable%pattern}          # if the pattern matches the end of the variable&#39;s value, delete the shortest part that matches and return the rest<br />${variable%%pattern}         # if the pattern matches the end of the variable&#39;s value, delete the longest part that matches and return the rest<br />${variable/pattern/string}   # the longest match to pattern in variable is replaced by string. Only the first match is replaced<br />${variable//pattern/string}  # the longest match to pattern in variable is replaced by string. All matches are replaced<br /><br />${#varname}                  # returns the length of the value of the variable as a character string<br /><br />*(patternlist)               # matches zero or more occurrences of the given patterns<br />+(patternlist)               # matches one or more occurrences of the given patterns<br />?(patternlist)               # matches zero or one occurrence of the given patterns<br />@(patternlist)               # matches exactly one of the given patterns<br />!(patternlist)               # matches anything except one of the given patterns<br /><br />$(UNIX command)              # command substitution: runs the command and returns standard output<br /><br /><br />##############################################################################<br /># FUNCTIONS<br />##############################################################################<br /><br /><br /># The function refers to passed arguments by position (as if they were positional parameters), that is, $1, $2, and so forth.<br /># $@ is equal to &quot;$1&quot; &quot;$2&quot;... &quot;$N&quot;, where N is the number of positional parameters. $# holds the number of positional parameters.<br /><br /><br />function functname() {<br />  shell commands<br />}<br /><br />unset -f functname  # deletes a function definition<br />declare -f          # displays all defined functions in your login session<br /><br /><br />##############################################################################<br /># FLOW CONTROLS<br />##############################################################################<br /><br /><br />statement1 &amp;&amp; statement2  # and operator<br />statement1 || statement2  # or operator<br /><br />-a                        # and operator inside a test conditional expression<br />-o                        # or operator inside a test conditional expression<br /><br /># STRINGS<br /><br />str1 == str2               # str1 matches str2<br />str1 != str2               # str1 does not match str2<br />str1 &lt; str2                # str1 is less than str2 (alphabetically)<br />str1 &gt; str2                # str1 is greater than str2 (alphabetically)<br />str1 \&gt; str2               # str1 is sorted after str2<br />str1 \&lt; str2               # str1 is sorted before str2<br />-n str1                    # str1 is not null (has length greater than 0)<br />-z str1                    # str1 is null (has length 0)<br /><br /># FILES<br /><br />-a file                   # file exists or its compilation is successful<br />-d file                   # file exists and is a directory<br />-e file                   # file exists; same -a<br />-f file                   # file exists and is a regular file (i.e., not a directory or other special type of file)<br />-r file                   # you have read permission<br />-s file                   # file exists and is not empty<br />-w file                   # your have write permission<br />-x file                   # you have execute permission on file, or directory search permission if it is a directory<br />-N file                   # file was modified since it was last read<br />-O file                   # you own file<br />-G file                   # file&#39;s group ID matches yours (or one of yours, if you are in multiple groups)<br />file1 -nt file2           # file1 is newer than file2<br />file1 -ot file2           # file1 is older than file2<br /><br /># NUMBERS<br /><br />-lt                       # less than<br />-le                       # less than or equal<br />-eq                       # equal<br />-ge                       # greater than or equal<br />-gt                       # greater than<br />-ne                       # not equal<br /><br />if condition<br />then<br />  statements<br />[elif condition<br />  then statements...]<br />[else<br />  statements]<br />fi<br /><br />for x in {1..10}<br />do<br />  statements<br />done<br /><br />for name [in list]<br />do<br />  statements that can use $name<br />done<br /><br />for (( initialisation ; ending condition ; update ))<br />do<br />  statements...<br />done<br /><br />case expression in<br />  pattern1 )<br />    statements ;;<br />  pattern2 )<br />    statements ;;<br />esac<br /><br />select name [in list]<br />do<br />  statements that can use $name<br />done<br /><br />while condition; do<br />  statements<br />done<br /><br />until condition; do<br />  statements<br />done<br /><br />##############################################################################<br /># COMMAND-LINE PROCESSING CYCLE<br />##############################################################################<br /><br /><br /># The default order for command lookup is functions, followed by built-ins, with scripts and executables last.<br /># There are three built-ins that you can use to override this order: `command`, `builtin` and `enable`.<br /><br />command  # removes alias and function lookup. Only built-ins and commands found in the search path are executed<br />builtin  # looks up only built-in commands, ignoring functions and commands found in PATH<br />enable   # enables and disables shell built-ins<br /><br />eval     # takes arguments and run them through the command-line processing steps all over again<br /><br /><br />##############################################################################<br /># INPUT/OUTPUT REDIRECTORS<br />##############################################################################<br /><br /><br />cmd1|cmd2  # pipe; takes standard output of cmd1 as standard input to cmd2<br />&lt; file     # takes standard input from file<br />&gt; file     # directs standard output to file<br />&gt;&gt; file    # directs standard output to file; append to file if it already exists<br />&gt;|file     # forces standard output to file even if noclobber is set<br />n&gt;|file    # forces output to file from file descriptor n even if noclobber is set<br />&lt;&gt; file    # uses file as both standard input and standard output<br />n&lt;&gt;file    # uses file as both input and output for file descriptor n<br />n&gt;file     # directs file descriptor n to file<br />n&lt;file     # takes file descriptor n from file<br />n&gt;&gt;file    # directs file description n to file; append to file if it already exists<br />n&gt;&amp;        # duplicates standard output to file descriptor n<br />n&lt;&amp;        # duplicates standard input from file descriptor n<br />n&gt;&amp;m       # file descriptor n is made to be a copy of the output file descriptor<br />n&lt;&amp;m       # file descriptor n is made to be a copy of the input file descriptor<br />&amp;&gt;file     # directs standard output and standard error to file<br />&lt;&amp;-        # closes the standard input<br />&gt;&amp;-        # closes the standard output<br />n&gt;&amp;-       # closes the ouput from file descriptor n<br />n&lt;&amp;-       # closes the input from file descripor n<br /><br /><br />##############################################################################<br /># PROCESS HANDLING<br />##############################################################################<br /><br /><br /># To suspend a job, type CTRL+Z while it is running. You can also suspend a job with CTRL+Y.<br /># This is slightly different from CTRL+Z in that the process is only stopped when it attempts to read input from terminal.<br /># Of course, to interrupt a job, type CTRL+C.<br /><br />myCommand &amp;  # runs job in the background and prompts back the shell<br /><br />jobs         # lists all jobs (use with -l to see associated PID)<br /><br />fg           # brings a background job into the foreground<br />fg %+        # brings most recently invoked background job<br />fg %-        # brings second most recently invoked background job<br />fg %N        # brings job number N<br />fg %string   # brings job whose command begins with string<br />fg %?string  # brings job whose command contains string<br /><br />kill -l               # returns a list of all signals on the system, by name and number<br />kill PID              # terminates process with specified PID<br />kill -s SIGKILL 4500  # sends a signal to force or terminate the process<br />kill -15 913          # Ending PID 913 process with signal 15 (TERM)<br />kill %1               # Where %1 is the number of job as read from &#39;jobs&#39; command.<br /><br />ps           # prints a line of information about the current running login shell and any processes running under it<br />ps -a        # selects all processes with a tty except session leaders<br /><br />trap cmd sig1 sig2  # executes a command when a signal is received by the script<br />trap &quot;&quot; sig1 sig2   # ignores that signals<br />trap - sig1 sig2    # resets the action taken when the signal is received to the default<br /><br />disown &lt;PID|JID&gt;    # removes the process from the list of jobs<br /><br />wait                # waits until all background jobs have finished<br /><br /><br />##############################################################################<br /># TIPS &amp; TRICKS<br />##############################################################################<br /><br /><br /># set an alias<br />cd; nano .bash_profile<br />&gt; alias gentlenode=&#39;ssh admin@gentlenode.com -p 3404&#39;  # add your alias in .bash_profile<br /><br /># to quickly go to a specific directory<br />cd; nano .bashrc<br />&gt; shopt -s cdable_vars<br />&gt; export websites=&quot;/Users/mac/Documents/websites&quot;<br /><br />source .bashrc<br />cd $websites<br /><br /><br />##############################################################################<br /># DEBUGGING SHELL PROGRAMS<br />##############################################################################<br /><br /><br />bash -n scriptname  # don&#39;t run commands; check for syntax errors only<br />set -o noexec       # alternative (set option in script)<br /><br />bash -v scriptname  # echo commands before running them<br />set -o verbose      # alternative (set option in script)<br /><br />bash -x scriptname  # echo commands after command-line processing<br />set -o xtrace       # alternative (set option in script)<br /><br />trap &#39;echo $varname&#39; EXIT  # useful when you want to print out the values of variables at the point that your script exits<br /><br />function errtrap {<br />  es=$?<br />  echo &quot;ERROR line $1: Command exited with status $es.&quot;<br />}<br /><br />trap &#39;errtrap $LINENO&#39; ERR  # is run whenever a command in the surrounding script or function exits with non-zero status<br /><br />function dbgtrap {<br />  echo &quot;badvar is $badvar&quot;<br />}<br /><br />trap dbgtrap DEBUG  # causes the trap code to be executed before every statement in a function or script<br /># ...section of code in which the problem occurs...<br />trap - DEBUG  # turn off the DEBUG trap<br /><br />function returntrap {<br />  echo &quot;A return occurred&quot;<br />}<br /><br />trap returntrap RETURN  # is executed each time a shell function or a script executed with the . or source commands finishes executing<br /><br />##############################################################################<br /># COLORS AND BACKGROUNDS <br />##############################################################################<br /><br /># Reset<br />Color_Off=&#39;\033[0m&#39; # Text Reset<br /><br /># Regular Colors<br />Black=&#39;\033[0;30m&#39;  # Black<br />Red=&#39;\033[0;31m&#39;    # Red<br />Green=&#39;\033[0;32m&#39;  # Green<br />Yellow=&#39;\033[0;33m&#39; # Yellow<br />Blue=&#39;\033[0;34m&#39;   # Blue<br />Purple=&#39;\033[0;35m&#39; # Purple<br />Cyan=&#39;\033[0;36m&#39;   # Cyan<br />White=&#39;\033[0;97m&#39;  # White<br /><br /># Additional colors<br />LGrey=&#39;\033[0;37m&#39;  # Ligth Gray<br />DGrey=&#39;\033[0;90m&#39;  # Dark Gray<br />LRed=&#39;\033[0;91m&#39;   # Ligth Red<br />LGreen=&#39;\033[0;92m&#39; # Ligth Green<br />LYellow=&#39;\033[0;93m&#39;# Ligth Yellow<br />LBlue=&#39;\033[0;94m&#39;  # Ligth Blue<br />LPurple=&#39;\033[0;95m&#39;# Light Purple<br />LCyan=&#39;\033[0;96m&#39;  # Ligth Cyan<br /><br /><br /># Bold<br />BBlack=&#39;\033[1;30m&#39; # Black<br />BRed=&#39;\033[1;31m&#39;   # Red<br />BGreen=&#39;\033[1;32m&#39; # Green<br />BYellow=&#39;\033[1;33m&#39;# Yellow<br />BBlue=&#39;\033[1;34m&#39;  # Blue<br />BPurple=&#39;\033[1;35m&#39;# Purple<br />BCyan=&#39;\033[1;36m&#39;  # Cyan<br />BWhite=&#39;\033[1;37m&#39; # White<br /><br /># Underline<br />UBlack=&#39;\033[4;30m&#39; # Black<br />URed=&#39;\033[4;31m&#39;   # Red<br />UGreen=&#39;\033[4;32m&#39; # Green<br />UYellow=&#39;\033[4;33m&#39;# Yellow<br />UBlue=&#39;\033[4;34m&#39;  # Blue<br />UPurple=&#39;\033[4;35m&#39;# Purple<br />UCyan=&#39;\033[4;36m&#39;  # Cyan<br />UWhite=&#39;\033[4;37m&#39; # White<br /><br /># Background<br />On_Black=&#39;\033[40m&#39; # Black<br />On_Red=&#39;\033[41m&#39;   # Red<br />On_Green=&#39;\033[42m&#39; # Green<br />On_Yellow=&#39;\033[43m&#39;# Yellow<br />On_Blue=&#39;\033[44m&#39;  # Blue<br />On_Purple=&#39;\033[45m&#39;# Purple<br />On_Cyan=&#39;\033[46m&#39;  # Cyan<br />On_White=&#39;\033[47m&#39; # White<br /><br /># Example of usage<br />echo -e &quot;${Green}This is GREEN text${Color_Off} and normal text&quot;<br />echo -e &quot;${Red}${On_White}This is Red test on White background${Color_Off}&quot; <br /># option -e is mandatory, it enable interpretation of backslash escapes<br /></div>
</body>
</html>
