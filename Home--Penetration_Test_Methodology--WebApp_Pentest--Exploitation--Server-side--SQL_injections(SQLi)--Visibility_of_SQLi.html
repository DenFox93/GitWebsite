<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Visibility of SQLi</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Visibility of SQLi</h1><br/><br /><strong><h3>What we need to keep an eye on</h3></strong><br />While <span style="text-decoration:underline;">SQL injection is typically not found as commonly as before</span> (due to new changes such as PHP Data Objects (PDO), a database access layer providing a uniform method of access to multiple databases types) it is still always worth testing for as they may be filtering certain characters to prevent SQL injection. <br />One thing to note is <span style="text-decoration:underline;">typically legacy code is more vulnerable to SQL injection</span> so keep an eye out for old features. <br />When <span style="text-decoration:underline;">testing for SQL injection yes you could simply use </span><strong><span style="text-decoration:underline;">&#39;</span></strong><span style="text-decoration:underline;"> and look for errors</span> but a lot has changed since the past &amp; these days a lot of developers have disabled error messages so<br /><a href="enetration_Test_Methodology--WebApp_Pentest--Exploitation--Server-side--SQL_injections(SQLi)--Visibility_of_SQLi--Blind_SQLi_Blind_Timing.html">Time-based Blind SQLi</a><a href="enetration_Test_Methodology--WebApp_Pentest--Exploitation--Server-side--SQL_injections(SQLi)--Visibility_of_SQLi--Blind_SQLi_Blind_Timing.html">(sleep payload)</a> usually will slip through any filtering.  As well as this it is easier to indicate if there is a delay on the response which would mean your payload was executed blindly. <br /><br /><strong><h3>Visibility of SQLi flwas</h3></strong><br />• <strong>In-Band/Inline SQLi</strong> → the end user(penetration tester) can see, largely unfettered, the results of the SQLi directly. This makes this class of SQLi flaw the simplest for us to both discover and exploit<br />   ◇ How recognize it?<br />      ▪ database error messages. This indicate a problem with the DB, which we presume is based on something we submitted. In fact, the most common way to initially attempt discovery of SQL flaws is to simply submit characters that are likely to cause a DB error message<br />      <a href=""><img src="images/348-1.png" alt="images/348-1.png" /></a><br />      <a href=""><img src="images/348-2.png" alt="images/348-2.png" /></a><br />• <strong>Inferential/Blind SQLi</strong> →  This type of SQL injection is different from the previous one, as it is not possible to see the errors or the results in the application&#39;s response. We need to infer what is happening in the application&#39;s backend or use external channels to get the information. At the same time, into the inferential SQL injections are further divided into two types:<br />   ◇ <span style="text-decoration:underline;">Boolean-based blind SQL injection</span>: In this type of SQL injection, the statements are focused on changing a Boolean value into the application in order to get different responses. Even though the SQL injection result is not showed directly, the HTTP response content could change to infer the result.<br />   ◇ <span style="text-decoration:underline;">Time-based blind SQL injection</span>: This inferential SQL injection depends on the time lapsed to generate a response by the database server. With time variations, it is possible to infer whether the SQL injection is successful or not. To do so, the malicious user inserts functions included in the DBMS to determine what is happening in the backend.<br />   ◇ <span style="text-decoration:underline;">Out-of-band SQL injection</span>: In this type of SQL injection, it is not possible to use the same channel to see the error response or infer the result directly. So, we need to use an external channel to know whether the SQL injection is successful or not. For example, using second data storage to receive the results, such as DNS resolution to infer the time lapsed in a request, which is not possible to see in the application.<strong><br /></strong><br /><br /><br />bibliography:<br />The Web Application Hacker&#39;s Handbook</div>
</body>
</html>
