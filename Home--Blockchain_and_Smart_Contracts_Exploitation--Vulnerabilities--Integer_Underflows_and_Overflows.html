<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title> Integer Underflows and Overflows</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'> Integer Underflows and Overflows</h1><br/><br /><strong>When overflow and underflows can occur?</strong><br />Integer overflow and underflows <span style="text-decoration:underline;">can occur when user supplied data controls the value of an unsigned integer</span>. When user supplied data can either adds to or subtracts beyond the limits the variable type can hold. <br /><br /><strong>Variable types constraints</strong><br />In fact, each variable type can hold up to a certain value length. Some variable types only hold positive numbers while others hold positive and negative numbers.<br />The types of numbers they are allowed to hold is based on their “signedness.” An unsigned integer can only hold positive numbers while a signed integer can hold positive and negative numbers.<br /><br /><strong>What happens when the variable type constraints is violated?</strong><br />If you violate the value constraints of the variable type you are using, <span style="text-decoration:underline;">the application may act in unintended ways</span>. <br />For example the overflow may result in an error condition for accessing out of bounds items or perhaps cutting the number off at the maximum or minimum value. This usually depends on the language in use, the context in which the value is used or the decisions taken by the programmer when flagging error conditions. If un-handled, the error from an attacker’s perspective is usually an opportunity for exploitation.<br /><br /><span style="color:#a5452a;">example:</span> if you were calculating a number for an authorization check within an application and the calculation contains an unchecked value with user-controlled data. Then an attacker may be able to bypass authorization restrictions with that user-controlled data and gain additional access to unintended services. For example, overflowing a larger unsigned value to a more advantageous value, such as zero or one, these lower values could bypass security checks. The first (“1”) value in a dataset is often indicative of an administrator who set up the application and may create a situation to persist actions with administrative context.<br /><br /><strong>Solidity Maths</strong><br />In the Solidity language for Ethereum, when we overflow a uint value using a value larger than our uint can hold, the value wraps back around to a number it understands. The lowest or highest possible value the uint can hold. For example, if we have a variable that can only hold a 2-digit number when the number 99 is reached and then incremented one more time, we will end up with 00. Inversely if we had 00 and we decremented 1 we would end up with 99.<br /><br />   ◇ Normally in your math class the following would be true:<br />       99 + 1 = 100<br />       00 - 1 = -1<br /><br />   ◇ In solidity with <span style="text-decoration:underline;">unsigned numbers</span> the following is true:<br />       99 + 1 = 00<br />       00 - 1 = 99<br /><br /><strong>Require statement not accurate in the context of the mathematical operation</strong><br />So, the issue lies with the assumption that a number will provide a correct value in mathematical calculations when indeed it does not. Comparing a variable with a <span style="text-decoration:underline;">require statement is not sufficiently accurate after performing a mathematical operation that can overflows a value</span>, because it does not check that the value is accurate in the context of the mathematical operation.<br /><br />In an overflow conditions the comparison with a require statement may very well be comparing the output of an over/under flowed value and be completely meaningless. The “Require” statement may return true, but not based on the actual intended mathematical value.<br /><br />This in turn will lead to an action performed which is beneficial to the attacker, for example, checking a low value required for a funds validation but then receiving a very high value sent to the attacker after the initial check. <br /></div>
</body>
</html>
