<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>ssh Dynamic Port Forwarding</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>ssh Dynamic Port Forwarding</h1><br /><br /><strong>
      <h3>Requirements:</h3>
    </strong><br />• SSH server installed on pivot host<br />• Connectivity to SSH port (22) on the pivot host with
    credentials for user@pivotSystem<br /><br /><strong>
      <h3>1. establish dynamic port forward</h3>
    </strong><br /> ◇ <strong>SSH dynamic port forwarding </strong><br /> SSH dynamic port forwarding via SOCKS (Socket
    Secure) allows arbitrary connections to be proxied to a remote host. Any application that can use a SOCKS can
    receive and transmit data through the tunnel.<br /> It listens on a local port established when the connection is
    set up. Anything sent to the local port is forwarded through the SSH tunnel<br /> We have to run this command from
    the attacker machine against the pivot(exploited?) machine. If the user is an administrator will ask us a
    password<br />
    <div class="codebox">
      <div class="codebox">
        ssh&nbsp;-D&nbsp;&lt;AttackerIP&gt;:&lt;AttackerSocksProxyPort&gt;&nbsp;-f&nbsp;-N&nbsp;user@<span
          style="color:#000000;font-weight:400">&lt;</span>IPpivotSystem<span
          style="color:#000000;font-weight:400">&gt;</span></div>
    </div><br /> –f → tells SSH to run in the background <br /> –N → tells SSH not to run a remote command <br /> <span
      style="color:#a5452a;">example:</span><br />
    <div class="codebox">
      <div class="codebox">ssh&nbsp;-N&nbsp;-D&nbsp;127.0.0.1:1080&nbsp;user@192.168.1.125</div>
    </div><br /><br /> <br /><strong>
      <h3>2. Set the SOCKS proxy settings</h3>
    </strong><br />
    <h3> ◇ </h3><strong>
      <h3>Enable proxy settings for Linux application with proxychains</h3>
    </strong>
    <h3> </h3><br /> Linux applications that don&#39;t have the capability to support a proxy can be forced to proxy
    with a tool called &quot;proxychains&quot;.<br /> Proxychains works by replacing standard libraries (via LD_PRELOAD)
    to trick the application into communication though the proxy.<br /> The port used by proxychains is set in the <span
      style="text-decoration:underline;">/etc/proxychains.conf</span> file; the default is TCP/9050. Change it to
    1080<br /> <a href=""><img src="images/778-1.png" alt="images/778-1.png" /></a><br /> if we wnat to use burpsuite as
    proxy add to proxychains.conf:<br />
    <div class="codebox">
      <div class="codebox">
        #burpsuite<br />http&nbsp;&nbsp;&nbsp;&nbsp;127.0.0.1&nbsp;8080<br />https&nbsp;&nbsp;&nbsp;127.0.0.1&nbsp;8080
      </div>
    </div><br /> <strong>To use with python3 scripts </strong><br /> see also: <a
      href="https://blog.ropnop.com/proxying-cli-tools/" target="_blank">https://blog.ropnop.com/proxying-cli-tools/</a><br /> convert
    from .der to .crt → The DER format is simply a binary form of a certificate instead of the ASCII PEM format. It
    sometimes has a file extension of .der but it often has a file extension of .crt so the only way to tell the
    difference between a DER .crt file and a PEM .crt file is to open it in a text editor and look for the BEGIN/END
    statements. <br />
    <div class="codebox">
      <div class="codebox">
        openssl&nbsp;x509&nbsp;-inform&nbsp;DER&nbsp;-in&nbsp;/home/kali/Downloads/cacert.der&nbsp;-out&nbsp;/home/kali/Downloads/cacert.crt<br />python3&nbsp;-c&nbsp;&quot;import&nbsp;certifi;&nbsp;print(certifi.where())&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#from&nbsp;which&nbsp;file&nbsp;python3&nbsp;load&nbsp;certificate&nbsp;for&nbsp;SSL<br />cat&nbsp;&nbsp;/home/kali/Downloads/cacert.crt&nbsp;&gt;&gt;&nbsp;/etc/ssl/certs/ca-certificates.crt
      </div>
    </div><br /> <br /> If the port set with SSH and proxychains.conf match(in our example we have to change it to
    1080), you can send traffic from non-proxy aware-applications through the tunnel like this:<br />
    <div class="codebox">
      <div class="codebox">proxychains&nbsp;<span
          style="color:#000000;font-weight:400">&lt;</span>command&nbsp;of&nbsp;the&nbsp;application&nbsp;and&nbsp;its&nbsp;options<span
          style="color:#000000;font-weight:400">&gt;</span></div>
    </div><br /> <span style="color:#a5452a;">examples:</span><br />
    <div class="codebox">
      <div class="codebox">proxychains&nbsp;nmap&nbsp;-n&nbsp;-sT&nbsp;-Pn&nbsp;-p&nbsp;&lt;ports&gt;&nbsp;<span
          style="color:#000000;font-weight:400">&lt;</span>otherTargetIP<span
          style="color:#000000;font-weight:400">&gt;</span></div>
    </div><br />
    <div class="codebox">
      <div class="codebox">
        proxychains&nbsp;python3&nbsp;GitDorker.py&nbsp;-tf&nbsp;/home/kali/bin/GitDorker/tokens.txt&nbsp;-org&nbsp;tesla&nbsp;-d&nbsp;/home/kali/bin/GitDorker/Dorks/alldorks.txt
      </div>
    </div><br />
    <h3> ◇ </h3><strong>
      <h3>Enable proxy settings for Metasploit</h3>
    </strong><br /> We have set the exploit and the payload for the TargetIP<br />
    <div class="codebox">
      <div class="codebox">
        msf&nbsp;&gt;&nbsp;use&nbsp;&lt;exploit&gt;<br />msf&nbsp;&gt;&nbsp;set&nbsp;RHOST&nbsp;&lt;TargetIP&gt;<br />msf&nbsp;&gt;&nbsp;set&nbsp;RPORT&nbsp;&lt;TargetPort&gt;<br />msf&nbsp;&gt;&nbsp;set&nbsp;Proxies&nbsp;socks4:127.0.0.1:1080<br />msf&nbsp;&gt;&nbsp;set&nbsp;ReverseAllowProxy&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#tells&nbsp;Metasploit&nbsp;that&nbsp;the&nbsp;reverse&nbsp;connection&nbsp;will&nbsp;be&nbsp;outside&nbsp;of&nbsp;the&nbsp;proxy.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#in&nbsp;fact&nbsp;how&nbsp;you&nbsp;can&nbsp;see&nbsp;we&nbsp;do&nbsp;not&nbsp;have&nbsp;used&nbsp;the&nbsp;reverse_tcp&nbsp;payload
      </div>
    </div><br />
    <h3> ◇ </h3><strong>
      <h3>Enable proxy settings for the Browser</h3>
    </strong><strong>(not so useful for now..)</strong><br /> <a href=""><img src="images/778-2.png"
        alt="images/778-2.png" /></a><br /> We can use them to mirror the results obtained from a webserver only
    accessible from the pivotSystem and not from the outside. <br /> Browsers can be configured to use SOCKS proxy (do
    not confuse with the HTTP proxy settings is a different proxy technology with a different protocol)<br /> The
    settings to configure SOCKS proxy can be found usually under preferences &gt; network tab &gt; configuration
    settings<br /> host: &lt;AttackerLoopbackIP&gt; and port: &lt;AttackerPort&gt; <br /> <span
      style="text-decoration:underline;">Or we can use FoxyProxy</span><br />
    <h3> </h3><br />Bibliography:<br />• <a
      href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot" target="_blank">https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot</a><br />•
    <a href="https://zaiste.net/posts/ssh-port-forwarding/" target="_blank">https://zaiste.net/posts/ssh-port-forwarding/</a><br />• <a
      href="https://pen-testing.sans.org/resources/papers/gwapt/tunneling-pivoting-web-application-penetration-testing-120229" target="_blank">https://pen-testing.sans.org/resources/papers/gwapt/tunneling-pivoting-web-application-penetration-testing-120229</a><br /><br />#burpsuite<br />http
    127.0.0.1 8080<br />https 127.0.0.1 8080<br />
  </div>
</body>

</html>