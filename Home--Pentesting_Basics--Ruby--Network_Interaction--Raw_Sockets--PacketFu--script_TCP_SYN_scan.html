<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>script: TCP SYN scan</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>script: TCP SYN scan</h1><br/><br /><strong>TCP SYN flood</strong>: Famous DOS attack based on TCP SYN packets. An attacker sends a flood of TCP SYN packets, forcing the target host to allocate a lot of resources reserved to the incoming connections until a crash happens.<br /><strong>TCP SYN scan</strong>: port scanner that avoids finalizing the tcp 3-way handshake. Like when we use <a href="Test_Methodology--Network_Pentest--Scanning_and_Enumeration--Port_Scanning_(on_hosts_alive)--nmap_[-s]--SCAN_TECHNIQUES---sS_TCP_SYN_Scan.html">nmap -sS</a> instead of <a href="_Methodology--Network_Pentest--Scanning_and_Enumeration--Port_Scanning_(on_hosts_alive)--nmap_[-s]--SCAN_TECHNIQUES---sT_TCP_Connect_Scan.html">nmap -sT</a><br /><br />Single Port scan:<br />	<a href=""><img src="images/1968-1.png" alt="images/1968-1.png" /></a><br />	   <a href="file://C:/CherryTree/screenshots2/PTP-elearnsecurity/2. Network Security/2. Scanning/-sS_port_open.png"><img src="images/1968-2.png" alt="images/1968-2.png" /></a><a href=""><img src="images/1968-3.png" alt="images/1968-3.png" /></a><br /><br /><br />Ruby Script<br /><div class="codebox"><div class="codebox">#&nbsp;TCP&nbsp;SYN&nbsp;PORT&nbsp;SCANNER<br /><br />#USAGE:<br />#&nbsp;ruby&nbsp;tcp_syn_scan.rb&nbsp;[host]&nbsp;[start_port]-[end_port]<br /><br />require&nbsp;&#39;packetfu&#39;<br />include&nbsp;PacketFu<br /><br /><br />def&nbsp;main(host,start_port,end_port)<br />	open&nbsp;=&nbsp;[];&nbsp;closed&nbsp;=&nbsp;[]<br />	#start&nbsp;packet&nbsp;sniffer<br />	start_capture(host,open,closed,start_port,end_port)<br />	#send&nbsp;the&nbsp;TCP&nbsp;SYN&nbsp;packet&nbsp;for&nbsp;each&nbsp;port&nbsp;we&nbsp;want&nbsp;to&nbsp;test<br />	send_tcp_syn(host,start_port,end_port)<br />	#The&nbsp;ports&nbsp;that&nbsp;are&nbsp;filtered&nbsp;are&nbsp;the&nbsp;ones&nbsp;that&nbsp;are&nbsp;not&nbsp;opened&nbsp;or&nbsp;closed<br />	filtered=(start_port..end_port).to_a&nbsp;-&nbsp;(open+closed)<br />	puts&nbsp;&quot;OPEN&quot;,open&nbsp;if&nbsp;!open.empty?<br />	puts&nbsp;&quot;FILTERED&quot;,filtered&nbsp;if&nbsp;!filtered.empty?<br />end<br /><br /><br /><br /><br />def&nbsp;send_tcp_syn(host,start_port,end_port)<br />	#create&nbsp;a&nbsp;TCPPacket&nbsp;<br />	t&nbsp;=&nbsp;TCPPacket.new(:config&nbsp;=&gt;&nbsp;Utils.whoami?)<br />	#set&nbsp;the&nbsp;correct&nbsp;mac&nbsp;address<br />	#&nbsp;--&gt;&nbsp;UNCHANGED:&nbsp;default&nbsp;gateway,&nbsp;because&nbsp;the&nbsp;host&nbsp;is&nbsp;outside&nbsp;the&nbsp;network<br />	#&nbsp;--&gt;&nbsp;CHANGE:&nbsp;host&nbsp;mac&nbsp;address&nbsp;coming&nbsp;from&nbsp;ARP&nbsp;request&nbsp;if&nbsp;the&nbsp;host&nbsp;belongs&nbsp;to&nbsp;the&nbsp;network<br />	t.eth_daddr&nbsp;=&nbsp;Utils.arp(host)&nbsp;if&nbsp;Utils.arp(host)<br />	t.ip_daddr&nbsp;=&nbsp;host<br />	t.tcp_flags.syn&nbsp;=&nbsp;1<br />	#for&nbsp;each&nbsp;port<br />	start_port.upto(end_port)&nbsp;do&nbsp;|port|<br />		t.tcp_dport&nbsp;=&nbsp;port<br />		t.recalc<br />		#send&nbsp;a&nbsp;TCP&nbsp;SYN&nbsp;packet,&nbsp;two&nbsp;times&nbsp;to&nbsp;avoid&nbsp;packets&nbsp;loss<br />		#&nbsp;sleep&nbsp;method&nbsp;avoid&nbsp;creating&nbsp;a&nbsp;flood&nbsp;of&nbsp;SYN&nbsp;packets&nbsp;against&nbsp;the&nbsp;target&nbsp;host<br />		#&nbsp;otherwise&nbsp;the&nbsp;target&nbsp;host&nbsp;may&nbsp;become&nbsp;suspicious<br />		2.times.each&nbsp;{&nbsp;t.to_w;sleep(0.02)}<br />	end<br />	sleep(1)<br />end<br /><br /><br /><br />def&nbsp;start_capture(host,open,closed,start_port,end_port)<br />	#a&nbsp;new&nbsp;thread&nbsp;is&nbsp;required;&nbsp;<br />	#&nbsp;because&nbsp;we&nbsp;sniff&nbsp;TCP&nbsp;SYN+ACK&nbsp;and&nbsp;RST+ACK&nbsp;at&nbsp;the&nbsp;same&nbsp;time&nbsp;we&nbsp;send&nbsp;TCP&nbsp;SYN.<br />	#&nbsp;otherwise&nbsp;some&nbsp;responses&nbsp;could&nbsp;be&nbsp;dropped&nbsp;by&nbsp;the&nbsp;PacketFu&nbsp;captured&nbsp;stream,&nbsp;because&nbsp;overloaded&nbsp;by&nbsp;a&nbsp;lot&nbsp;of&nbsp;packets<br />	Thread.new{<br />		cap&nbsp;=&nbsp;Capture.new<br />		cap.capture(:filter&nbsp;=&gt;&nbsp;(&quot;tcp&nbsp;and&nbsp;src&nbsp;host&nbsp;&quot;+host)&nbsp;)<br />		cap.stream.each&nbsp;do&nbsp;|raw_packet|<br />				tcp_packet&nbsp;=&nbsp;Packet.parse(raw_packet)<br />				port&nbsp;=&nbsp;tcp_packet.tcp_sport.to_i<br />				next&nbsp;if&nbsp;!port.between?(start_port,end_port)<br />				flags&nbsp;=&nbsp;tcp_packet.tcp_flags<br />				open.push(port)&nbsp;if&nbsp;(flags.syn==1&nbsp;&amp;&amp;&nbsp;flags.ack==1&nbsp;&amp;&amp;&nbsp;!open.include?(port))&nbsp;<br />				closed.push(port)&nbsp;if&nbsp;(flags.rst==1&nbsp;&amp;&amp;&nbsp;flags.ack==1&nbsp;&amp;&amp;&nbsp;!open.include?(port))<br />		end<br />	}<br />end<br /><br /><br />begin&nbsp;<br />	host&nbsp;=&nbsp;ARGV[0]<br /><br />	#&nbsp;EXAMPLE:&nbsp;from&nbsp;10-200&nbsp;argument&nbsp;we&nbsp;have&nbsp;<br />	#&nbsp;start_port&nbsp;=&nbsp;10&nbsp;and&nbsp;end_port&nbsp;=&nbsp;200<br />	start_port,end_port&nbsp;=&nbsp;ARGV[1].split(&quot;-&quot;).map{|x|&nbsp;x.to_i}<br />	main(host,start_port,end_port)	<br /><br />end<br /></div></div><br /><br />	<a href=""><img src="images/1968-4.png" alt="images/1968-4.png" /></a><br />   ◇ <span style="text-decoration:underline;">port open</span>:<br />	<a href=""><img src="images/1968-5.png" alt="images/1968-5.png" /></a><br />   ◇ <span style="text-decoration:underline;">port closed</span>:<br />	as we can see from wireshark the packet is transmitted 2 times, but this only because is been specified in the script <br />	<a href=""><img src="images/1968-6.png" alt="images/1968-6.png" /></a><br /><br /></div>
</body>
</html>
