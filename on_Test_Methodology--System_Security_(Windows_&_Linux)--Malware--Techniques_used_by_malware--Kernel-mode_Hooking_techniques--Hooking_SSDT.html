<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Hooking SSDT</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Hooking SSDT</h1><br/><br /><br /><strong>Hooking Native APIs / SSDT</strong><br />    Native API is an API which functions are declared in ntdll.dll and ntoskrnl.exe; they are basically used to communicate with kernel mode, this communication happens using SSDT(System Service Descriptor Table)<br />    For each task specified by the API there is an entry in SSDT table that match with a function in Kernel mode<br />    <a href=""><img src="images/565-1.png" alt="images/565-1.png" /></a><br />    The global variable <span style="text-decoration:underline;">KeServiceDescriptorTable</span> store the base address of the SSDT table that stores the addresses of Nt* or Zw* functions. Nt* and Zw* functions behave the same in urser mode, while behave little different in kernel mode<br />   <span style="text-decoration:underline;">Hooking</span><br />   Hooking the SSDT is one of the most popular rootkit technique.[1] <br />   It is possible to hook all system calls by modifying the system service table entry in the SSDT or by modifying the KeServiceDescriptorTable to point to a new SSDT, which contains a different value of the system service table entry and so our (malicious) function instead of the actual function<br />      <a href="file://C:/CherryTree/screenshots2/PTP-elearnsecurity/1. System Security/6 - Malware/SSDT.png"><img src="images/565-2.png" alt="images/565-2.png" /></a></div>
</body>
</html>
