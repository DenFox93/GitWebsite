<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Blockchain and Smart Contracts Exploitation</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Blockchain and Smart Contracts Exploitation</h1><br/><br /><strong><h3>Difference between Standard Applications and Decentralized Applications(dapp)</h3></strong><br />• <strong>Standard Application Model:</strong><br />    In client server we generally have the following:<br />   ◇ Front End →  what the user sees (HTML page, ...)<br />   ◇ Server Side →  code that handles business logic (such API that access to all the data)<br />   ◇ Back End →  Your database for example MySQL<br /><br />• <strong>Decentralized Application(Dapp) Model:</strong><br />    We have similar front end server side technology DAPPs (banking applications, wallets, video games, ...)  are Ethereum enabled applications using smart contracts as an API to the blockchain data ledger<br />   ◇ Front End → what the user sees (HTML page, ...) like any app<br />   ◇ Server Side → Smart contracts are your access into the blockchain. like an API<br />   ◇ Back End → It is distributed across thousands of nodes <span style="text-decoration:underline;">in its entirety on each node</span>.<br />      ▪ Every single node has a Full “database” of information called a ledger.  <br />      ▪ This ledger is immutable, meaning once data goes in, data cannot be changed. This will come into play later in this discussion about smart contracts.<br /><br /><br /><strong>Blockchain is Syncronized by a Consensus mechanism</strong><br />The blockchain of these decentralized ledgers is synchronized by a consensus mechanism, that verify the accuracy of each calculated blocks hash.<br />   ◇ <span style="text-decoration:underline;">Proof of Stake</span>.<br />    Proof of stake is simply staking large sums of coins which are at risk of loss if one were to perform a malicious action while helping to perform consensus of data.   <br />   ◇ <span style="text-decoration:underline;">Proof of Work (sometime called mining)</span><br />    Proof of Work(mining) validates hashing calculations to come to a consensus but instead of loss of coins there is a loss of energy, which costs money, without reward if malicious actions were to take place.<br /><br />Each block contains transactions from the transaction pool. Block transactions are combined with a nonce that meets the difficulty requirements currently on the network. Once a block is found and accepted it places them on the blockchain in which more then half of the network must reach a consensus on. <br />The point is that no central authority controls the nodes or can shut them down. Instead there is consensus from all nodes using either proof of work or proof of stake. They are spread across the whole world leaving a single centralized jurisdiction as an impossibility.<br /><br /><br /><br /><strong><h3>Things to Note: </h3></strong><br />• <strong>Immutability</strong><br />   Our smart contracts are located on the blockchain and the blockchain is immutable<br />   ◇ This means an Agile development model is not going to work once a contract is deployed.<br />   ◇ This means that updates to contracts is next to impossible<br />   ◇ All you can really do is create a kill-switch or fail safe functions. These functions disable the contract and execute some actions if something goes wrong before going permanently dormant.<br />   ◇ If you don’t include a kill switch the contract is open and available and you can&#39;t remove it<br /><br />• <strong>Code Is Open Source</strong><br />   ◇ Smart Contracts are generally open source<br />   ◇ Which means hackers can manually bug hunting smart contracts and running static analysis tools against smart contract&#39;s code looking for bugs.<br />   ◇ When issues are found the only course of action is:<br />      ▪ Kill the current contract (with a kill switch) which stays on the blockchain<br />      ▪ Then deploy a whole new version<br />      ▪ If there is no killSwitch the contract will be available forever.<br />   ◇ Because of the difficulties of address issues on smart contracts is advisable to keep them simple and keep any complicated logic in applications middle layer<br /><br />• <strong>Security in the development process is lacking</strong><br />   ◇ Many contracts and projects do not even think about Software Development Life Cycle (SDLC)<br />   ◇ They rarely add penetration testing and vulnerability testing in the development stages if at all<br />   ◇ At best there is a bug bounty before the release of their main-nets<br />   ◇ Which usually get hacked to hell and delayed because of it.<br />   ◇ Things are getting better but they are still behind the curve, as the technology is new and blockchain mostly developers and marketers. Not hackers or security testers.<br /><br />• <strong>Potential Data Exposure via Future Broken Crypto</strong><br />   ◇ If sensitive data is placed on the blockchain it is there forever<br />   ◇ Which means that if a cryptographic algorithm is broken anything which is encrypted with that algorithm is now accessible<br />   ◇ We all know that algorithms are eventually broken!<br />   ◇ So its always advisable to keep sensitive data hashed for integrity on the blockchain but not actually stored on the blockchain directly<br /><br /><strong><h3>IDEs</h3></strong><br />• Online Solidity IDE<br />   ◇ Remix →  <a href="http://remix.ethereum.org/">http://remix.ethereum.org/</a><br /><br /><br /><br /><br /><br /><br />Bibliography:<br />• <a href="http://console-cowboys.blogspot.com/2018/11/blockchain-exploitation-labs-part-1.html">http://console-cowboys.blogspot.com/2018/11/blockchain-exploitation-labs-part-1.html</a></div>
</body>
</html>
