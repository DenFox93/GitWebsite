<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Stored XSS (second-order OR persistent XSS)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>Stored XSS (second-order OR persistent XSS)</h1><br /><strong>Persistent XSS attacks</strong>
    happen when the payload is sent to a vulnerable web server and then is stored within the HTML code of the page. Then
    this malicious XSS payload gets delivered to each user that visit the “injected” web page.<br /><span
      style="text-decoration:underline;">Potential vectors for a XSS attacks</span>: are HTML forms (like comments and
    forum posts) that submit content to the web server and then these content are displayed back to the
    user<br /><br /><br />Common application functions with increased likelihood of Stored XSS flaws:<br />• input
    text<br /> ◇ Blog comments<br /> ◇ Forum data<br /> ◇ Messaging functionality<br /> ◇ Log mechanisms<br /> ◇ Account
    profile information<br /> ◇ Support functionality<br />• file upload<br /><br /><br /><strong>
      <h3>Testing for Stored XSS vulnerabilities manually involves the following steps:</h3>
    </strong><br />0. Many stored XSS vulnerabilities can be found using Burp Suite&#39;s <a
      href="https://portswigger.net/burp/vulnerability-scanner" target="_blank">web vulnerability scanner</a>. <br /> Intercept the
    possible vulnerable request in Burp → right click → Do active scan<br /> <a href=""><img src="images/337-1.png"
        alt="images/337-1.png" /></a><br /> <a href=""><img src="images/337-2.png" alt="images/337-2.png" /></a><br />
    Note: Burp will do a lot of request with a lot of different payloads, if all of them will be seen on the Website
    could cause trouble to the company and confusion.<br /><br />1. <strong>Test every entry point.</strong> Test
    separately every entry point for data within the application&#39;s HTTP requests. This includes:<br /> ◇ parameters
    within the URL query string (GET requests) and in the message body (POST requests)<br /> ▪ see chapter <a
      href="Home--Penetration_Test_Methodology--WebApp_Pentest--Scanning_(&_Footprinting)--Enumerate_parameters_(fuzzing).html">Enumerate
      Parameters</a> to find the parameters to be tested(with Arjun)<br />2. <strong>Submit random alphanumeric
      values.</strong> For each entry point, submit a unique random value and determine whether the value is reflected
    in the response. The value should be designed to survive most input validation, so needs to be fairly short and
    contain only alphanumeric characters. But it needs to be long enough to make accidental matches within the response
    highly unlikely. A random alphanumeric value of around 8 characters is normally ideal. <br /> You can use:<br /> ◇
    Openssl to generate random 4 bytes (8 hex symbols) and encode in hex<br />
    <div class="codebox">
      <div class="codebox">openssl&nbsp;rand&nbsp;-hex&nbsp;4</div>
    </div><br /> <a href=""><img src="images/337-3.png" alt="images/337-3.png" /></a><br /> ◇ Burp Intruder&#39;s grep
    payloads option to automatically flag responses that contain the submitted value.<br /> <a href=""><img
        src="images/337-4.png" alt="images/337-4.png" /></a><br />3. <strong>Determine the reflection
      context.</strong> For each location within the response where the random value is reflected, determine its
    context. This might be in text between HTML tags, within a tag attribute which might be quoted, within a JavaScript
    string, etc.<br /> ◇ see chapter <a
      href="p_Pentest--Exploitation--Client-Side--Cross_Site_Scripting(XSS)--Identify_XSS_contexts--Determine_location_of_the_request_in_the_response.html">Determine
      location of the request in the response</a><br />4. <strong>Test a candidate payload.</strong> Based on the
    context of the reflection (HTML content, tag attribute, existing Javascript code) determined with the previous
    point, test an initial candidate XSS payload that will trigger JavaScript execution if it is reflected unmodified
    within the response. <br /> ◇ see chapter <a
      href="p_Pentest--Exploitation--Client-Side--Cross_Site_Scripting(XSS)--Identify_XSS_contexts--Determine_location_of_the_request_in_the_response.html">Determine
      location of the request in the response</a><br />5. <strong>Test alternative payloads.</strong> If the candidate
    XSS payload was modified by the application, or blocked altogether, then you will need to test alternative payloads
    and techniques that might deliver a working XSS attack based on the context of the reflection and the type of input
    validation that is being performed.<br /> ◇ see chapter <a
      href="est_Methodology--WebApp_Pentest--Exploitation--Client-Side--Cross_Site_Scripting(XSS)--Identify_XSS_contexts--WAF_bypass_and_filter_tests.html">WAF
      bypass and filter tests</a><br />6. <strong>Test the attack in a browser.</strong> Finally, if you succeed in
    finding a payload that appears to work within Burp Repeater, transfer the attack to:<br /> ◇ A browser by for
    example pasting the URL into the address bar (Note that the browsers could have Built-in XSS filter)<br /> ◇ Burp
    Proxy&#39;s intercept view<br /> Then see if the injected JavaScript is executed.
  </div>
</body>

</html>