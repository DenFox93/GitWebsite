<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Reflected XSS (Non-Persistent)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Reflected XSS (Non-Persistent)</h1><br/><strong><span style="text-decoration:underline;">Reflected</span></strong><span style="text-decoration:underline;"> attacks</span> happen when an input field(with a malicious payload) carried inside of a HTTP request(sent by the browser of the victim to the vulnerable website) gets reflected in the victim output page.<br />The attack can be triggered when a user click on the modified link<br /><br /><br /><strong><h3>Testing for reflected &amp; stored XSS vulnerabilities manually involves the following steps</h3></strong><strong>:</strong><br />1. <strong>Test every entry point.</strong> Test separately every entry point for data within the application&#39;s HTTP requests. This includes:<br />   ◇ parameters within the URL query string (GET requests) and in the message body (POST requests)<br />      ▪ see chapter <a href="Home--Penetration_Test_Methodology--WebApp_Pentest--Scanning_(&_Footprinting)--Enumerate_parameters_(fuzzing).html">Enumerate Parameters</a> to find the parameters to be tested(with Arjun)<br />2. <strong>Submit random alphanumeric values.</strong> For each entry point, submit a unique random value and determine whether the value is reflected in the response. The value should be designed to survive most input validation, so needs to be fairly short and contain only alphanumeric characters. But it needs to be long enough to make accidental matches within the response highly unlikely. A random alphanumeric value of around 8 characters is normally ideal. <br />    You can use:<br />   ◇ Openssl to generate random 4 bytes (8 hex symbols) and encode in hex<br />       <div class="codebox"><div class="codebox">openssl&nbsp;rand&nbsp;-hex&nbsp;4</div></div><br />        <a href=""><img src="images/336-1.png" alt="images/336-1.png" /></a><br />   ◇ Burp Intruder&#39;s grep payloads option to automatically flag responses that contain the submitted value.<br />       <a href=""><img src="images/336-2.png" alt="images/336-2.png" /></a><br />3. <strong>Determine the reflection context.</strong> For each location within the response where the random value is reflected, determine its context. This might be in text between HTML tags, within a tag attribute which might be quoted, within a JavaScript string, etc.<br />   ◇ see chapter <a href="p_Pentest--Exploitation--Client-Side--Cross_Site_Scripting(XSS)--Identify_XSS_contexts--Determine_location_of_the_request_in_the_response.html">Determine location of the request in the response</a><br />4. <strong>Test a candidate payload.</strong> Based on the context of the reflection (HTML content, tag attribute, existing Javascript code) determined with the previous point, test an initial candidate XSS payload that will trigger JavaScript execution if it is reflected unmodified within the response. <br />    ◇ see chapter <a href="p_Pentest--Exploitation--Client-Side--Cross_Site_Scripting(XSS)--Identify_XSS_contexts--Determine_location_of_the_request_in_the_response.html">Determine location of the request in the response</a><br />5. <strong>Test alternative payloads.</strong> If the candidate XSS payload was modified by the application, or blocked altogether, then you will need to test alternative payloads and techniques that might deliver a working XSS attack based on the context of the reflection and the type of input validation that is being performed.<br />   ◇ see chapter <a href="est_Methodology--WebApp_Pentest--Exploitation--Client-Side--Cross_Site_Scripting(XSS)--Identify_XSS_contexts--WAF_bypass_and_filter_tests.html">WAF bypass and filter tests</a><br />6. <strong>Test the attack in a browser.</strong> Finally, if you succeed in finding a payload that appears to work within Burp Repeater, transfer the attack to:<br />   ◇ A browser by for example pasting the URL into the address bar (Note that the browsers could have Built-in XSS filter)<br />   ◇ Burp Proxy&#39;s intercept view<br />   Then see if the injected JavaScript is executed. <br /><br /><br /><strong>What is the difference between reflected XSS and self-XSS? </strong><br />Self-XSS involves similar application behavior to regular reflected XSS, however it cannot be triggered in normal ways via a crafted URL or a cross-domain request. Instead, the vulnerability is only triggered if the victim themselves submits the XSS payload from their browser. Delivering a self-XSS attack normally involves socially engineering the victim to paste some attacker-supplied input into their browser. As such, it is normally considered to be a lame, low-impact issue.<br /><br /><br /><strong>Built-in XSS filter in Browsers</strong><br />Some browsers <span style="text-decoration:underline;">for the security of the user</span> have built-in reflected XSS filter<br />Anyway the reality is that they can filter only known XSS attacks. Advanced attacks can bypass XSS filter of the browser<br />Anti-XSS filters of a browser can not block <strong>persistent XSS</strong><br /><br /></div>
</body>
</html>
