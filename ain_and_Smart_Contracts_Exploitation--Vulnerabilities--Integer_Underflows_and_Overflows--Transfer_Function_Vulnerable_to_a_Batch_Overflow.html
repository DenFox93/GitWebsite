<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Transfer Function Vulnerable to a Batch Overflow</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Transfer Function Vulnerable to a Batch Overflow</h1><br/>Overflow conditions often happen in situations where you are sending a batched amount of values to multiple recipients. <br />If you are performing an airdrop, sending tokens to 200 users, each receiving a large sum of tokens, <span style="text-decoration:underline;">checking the total sum of all users’ tokens against the total funds may trigger an overflow</span>. The logic when overflowed would compare a smaller value of overflowed tokens to the total tokens and seem like you have enough to cover the transaction.<br /><br /><span style="color:#a020f0;">Vulnerable function to Batch Overflow</span><br />If your integer can only hold 5 digits in length or xx.xxx what would happen in the below scenario?<br />   ◇ balances[msg.sender] = 10000<br />   ◇ _users.length=200<br />   ◇ _tokens=500<br /> <br />    <div class="codebox"><div class="codebox">uint&nbsp;total&nbsp;=&nbsp;_users.length&nbsp;*&nbsp;_tokens;<br />//uint&nbsp;total&nbsp;=&nbsp;200&nbsp;*&nbsp;500;<br />require(balances[msg.sender]&nbsp;&gt;=&nbsp;total);<br />//require(10,000&nbsp;&gt;=&nbsp;0);<br />balances[msg.sender]&nbsp;=&nbsp;balances[msg.sender]&nbsp;-total;<br />//balances[msg.sender]&nbsp;=&nbsp;10,000&nbsp;-&nbsp;0;<br /><br />for(uint&nbsp;i=0;&nbsp;i&nbsp;&lt;&nbsp;users.length;&nbsp;i++){&nbsp;<br />//for(uint&nbsp;i=0;&nbsp;i&nbsp;&lt;&nbsp;500;&nbsp;i++){<br />&nbsp;&nbsp;&nbsp;&nbsp;balances[_users[i]]&nbsp;=&nbsp;balances[_users[i]]&nbsp;+&nbsp;_value;<br />&nbsp;&nbsp;&nbsp;&nbsp;//balances[_users[i]]&nbsp;=&nbsp;balances[_users[i]]&nbsp;+&nbsp;500;</div></div><br />    This is what happen:<br />    Line 1 → The total variable equals 100.000 which becomes 0 due to the 5-digit limit. When a 6th digit is hit at 99,999 + 1 the total now becomes 0.<br />        (not really true because uint actually hold 78 digits <a href="Home--Blockchain_and_Smart_Contracts_Exploitation--Solidity--2._State_Variables_&_Integers.html">as seen here</a>)<br />    Line 3 → require checks if the users balance is higher than the total value to be sent. Which in this case is 0 so 10,000 is more than enough and this check passes due to the overflow.<br />    Line 5 → deducts the total from the sender’s balance which does nothing since the total of 10,000 - 0 is 10,000.  The sender has lost no funds<br />    Line 8 → This loop iterates over the 200 users who each get 500 tokens and updates the balances of each user individually using the real value of 500 and this individual action does not trigger an overflow condition. Thus, sending out 100,000 tokens without reducing the sender’s balance or triggering an error due to lack of funds. This is essentially creating tokens out of thin air.<br />Conclusion: This mean that the tokens are been distribuited(500 to each user) but the funds of the contract are remained unchanged.<br /><br /><br /><br /><br />Bibliography:<br />• <a href="http://console-cowboys.blogspot.com/2020/08/smart-contract-hacking-chapter-3.html">http://console-cowboys.blogspot.com/2020/08/smart-contract-hacking-chapter-3.html</a></div>
</body>
</html>
