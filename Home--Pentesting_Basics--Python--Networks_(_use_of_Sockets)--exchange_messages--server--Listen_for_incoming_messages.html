<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Listen for incoming messages</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>Listen for incoming messages</h1><br />A <strong>server</strong> is a program that binds itself to
    a specific address and port and will listen for incoming TCP communications <br /><br />
    <div class="codebox">
      <div class="codebox">
        #!/usr/bin/env&nbsp;python3<br /><br />import&nbsp;socket<br /><br />SERVER_ADDRESS&nbsp;=&nbsp;&quot;192.168.1.29&quot;&nbsp;&nbsp;#&nbsp;address&nbsp;of&nbsp;this&nbsp;server&nbsp;127.0.0.1&nbsp;<br />SERVER_PORT&nbsp;=&nbsp;65432&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Port&nbsp;to&nbsp;listen&nbsp;on&nbsp;(non-privileged&nbsp;ports&nbsp;are&nbsp;&gt;&nbsp;1023)<br /><br />s=&nbsp;socket.socket(socket.AF_INET,&nbsp;socket.SOCK_STREAM)<br />s.bind((SERVER_ADDRESS,&nbsp;SERVER_PORT))<br />s.listen(1)&nbsp;&nbsp;&nbsp;#argument&nbsp;1&nbsp;specifies&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;queued&nbsp;connections<br />print(&quot;server&nbsp;started&nbsp;wainting&nbsp;for&nbsp;connection...&nbsp;&quot;)<br />conn,&nbsp;address&nbsp;=&nbsp;s.accept()<br />print(&quot;client&nbsp;connected&nbsp;with&nbsp;address&quot;,&nbsp;address)<br />while&nbsp;True:<br />&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;conn.recv(1024)<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;data:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br />&nbsp;&nbsp;&nbsp;&nbsp;conn.sendall(b&#39;---Message&nbsp;Received---\n&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;print(data.decode(&quot;utf-8&quot;))<br />conn.close<span
          style="color:#000000;font-weight:400">()</span></div>
    </div><br /><br />this is the message received from the client:<br /><a href=""><img src="images/208-1.png"
        alt="images/208-1.png" /></a><br /><br />• <strong>SERVER_ADDRESS = </strong><strong><span
        style="color:#3ad900;">&quot;192.168.1.29&quot;</span></strong> <br /> this is the address of the the machine
    from where we are executing the script.<br /> To make the script more transportable and let it executable on other
    machines we can replace it with: 0.0.0.0<br /> ◇ 127.0.0.1 → listening and accept only for local connections;
    connection coming from the same machine<br /> ◇ 0.0.0.0 → listen for every possible IP address<br />•
    <strong>SERVER_PORT = </strong><strong><span style="color:#ff0044;">65432</span></strong><strong> </strong><br />
    port&gt;1023<br />• <strong>s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)</strong><br /> function to create a
    socket object:<code> socket.socket(family, type, proto)</code><br /> ◇ The address family should be: AF_INET (the
    default: refers to the address family IPv4), AF_INET6, AF_UNIX, AF_CAN, AF_PACKET or AF_RDS.<br /> ◇ The socket type
    should be: SOCK_STREAM (the default: connection oriented TCP protocol), SOCK_DGRAM, SOCK_RAW <br /> ◇ The protocol
    number is usually zero and may be omitted or in the case where the address family is AF_CAN the protocol should be
    one of CAN_RAW, CAN_BCM or CAN_ISOTP<br />• s.bind((SERVER_ADDRESS, SERVER_PORT))<code><br /></code>
    <code>socket.bind(address)</code> → Bind the socket to the address(port is part of the address). The socket must not
    already be bound(The format of address depends on the address family)<br />• <strong>s.listen(</strong><strong><span
        style="color:#ff0044;">1</span></strong><strong>) </strong><br />
    <code>socket.listen(</code><code><span style="color:#ff0000;">backlog</span></code><code>)</code> → Listen for
    connections made to the socket. The <span style="color:#ff0000;">backlog</span> argument specifies the maximum
    number of <span style="text-decoration:underline;">queue of pending connections</span> and should be at least 0; the
    maximum value is system-dependent( in Linux 128 we can check the file: /proc/sys/net/core/somaxconn), the minimum
    value is forced to 0. <em>From version 3.5: The </em><em><span style="color:#ff0000;">backlog</span></em><em>
      parameter is optional</em><br />• <strong>conn, address = s.accept()</strong><br /> <code>socket.accept()</code> →
    Accept a connection. The socket must be bound to an address and listening for connections. <br /> The return value
    is a pair (conn, address) where <span style="text-decoration:underline;">conn</span> <strong>is a new
      socket</strong> object that we will use to send and receive data on the connection with the client( It’s distinct
    from the listening socket that the server is using to accept new connections), and <span
      style="text-decoration:underline;">address</span> will be a tuple (host, port) for IPv4 connections or (host,
    port, flowinfo, scopeid) for IPv6. <br />• <strong>data = conn.recv(1024)</strong><br />
    <code>socket.recv(bufsize,flags)</code> → Receive data from the socket. The return value is a string representing
    the data received. The maximum amount of data to be received at once is specified by <span
      style="text-decoration:underline;">bufsize</span><em>(For best match with hardware and network, the value of
      bufsize should be a power of 2, for example:1024,2048, 4096...)</em><br /> The optional argument flags for default
    is 0<br />• <strong>conn.sendall(</strong><strong><span style="color:#3ad900;">b&#39;---Message
        Received---\n&#39;</span></strong><strong>)</strong><br /> <code>socket.sendall(bytes, flags)</code> → Send data
    to the socket. The socket must be connected to a remote socket. Unlike send() that is a low-level method and
    basically just the C/syscall method, with sendall() there is no way to determine how much data, if any, is
    successfully sent.<br />• <strong>conn.close()</strong><br /> <code>socket.close()</code> → Close the socket. All
    future operations on the socket object will
    fail.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />bibliography:<br /><a
      href="https://docs.python.org/3/library/socket.html" target="_blank">https://docs.python.org/3/library/socket.html</a><br /><a
      href="https://docs.python.org/2/library/socket.html" target="_blank">https://docs.python.org/2/library/socket.html</a><br /><a
      href="https://realpython.com/python-sockets/#socket-api-overview" target="_blank">https://realpython.com/python-sockets/#socket-api-overview</a><br /><br /><br />
  </div>
</body>

</html>