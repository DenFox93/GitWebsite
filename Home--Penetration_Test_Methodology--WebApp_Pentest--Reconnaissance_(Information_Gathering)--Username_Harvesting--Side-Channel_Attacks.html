<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Side-Channel Attacks</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Side-Channel Attacks</h1><br/><br />A side-channel attack uses physical information, such as EMI, heat, and sound, to break a system. These are especially applicable to crypto attacks.<br /><br />For example, monitoring CPU utilization (or simply measuring CPU heat) can indicate CPU load during encryption<br />   ◇ This can be used to break the encryption<br /><br /><strong>Practical Side-Channel Attacks</strong><br />Sometime a Web Application hash the password only if the username is valid, because why hash the password for a bad username? This is the opportunity for an attacker that can discover good usernames<br />   ◇ Bad username →  Immediately return error<br />   ◇ Good username →  Hash the password. This create a small (but noticeable and measurable) delay returning an error for a good username/bad password<br />Modern interception proxies such as ZAP and Burp make this timing difference quite easy to measure<br /><span style="text-decoration:underline;">Solution</span>: Hash the password in both use cases, for both good usernames and bad. Although simple to accomplish, that design is not common (currently)<br /><br /><br /><br /><strong>Difference correct VS invalid username</strong><br />• ZAP:<br /><a href=""><img src="images/1519-1.png" alt="images/1519-1.png" /></a><br /><a href=""><img src="images/1519-2.png" alt="images/1519-2.png" /></a><br />We can note a higher RTT only for correct username. This because the password is hashed only for them.<br />The Timing-Attack is worked because the web developer used bcrypt to hash passwords for good usernames only.<br />Here is a PHP source code of a WebApp that can results in a timing attack:<br />    <div class="codebox"><div class="codebox">if($usergood&nbsp;==&nbsp;1)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;$options&nbsp;=&nbsp;[<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;cost&#39;&nbsp;=&gt;&nbsp;12,<br />&nbsp;&nbsp;&nbsp;&nbsp;];<br />&nbsp;&nbsp;&nbsp;&nbsp;$hash=password_hash(&quot;$pass&quot;,&nbsp;PASSWORD_BCRYPT,&nbsp;$options).&quot;\n&quot;;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br />• Burpsuite Intruder(Sniper):<br /><span style="color:#ff0000;text-decoration:underline;">Note</span><span style="color:#ff0000;">: in the example below we not have have clear results, probably because the attack is been done externally (&quot;from the internet&quot;) and not inside the same network. <br />    Because of that there are delays that we cannot control and the result are more random</span><br />1. Positions tab: select the value of the username that we want to change and click to add<br />3. Payloads tab:  Payload Options → select the usernames that you want to tests<br />    <a href=""><img src="images/1519-3.png" alt="images/1519-3.png" /></a><br />   ◇ <strong><span style="color:#ffa500;">Response received</span></strong> → The time taken to begin receiving a response (in milliseconds). <span style="text-decoration:underline;">This is the one to which we are interested in this scenario</span><br />      ▪ useful when we use a time-based attacks that cause a delay before a response starts (if the whole server-side logic is executed first)<br />   ◇ Response completed → The time taken for the response to complete (in milliseconds)<br />      ▪ useful when we use a time-based attacks that cause a delay while the response is already being streamed (e.g. if the headers are sent first, and then some further server-side processing happens on your input).<br /><br /></div>
</body>
</html>
