<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>create a Shellcode</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>create a Shellcode</h1><br/>1. <strong>C++ code</strong><br />In this example we will use the ShellExecute function<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;windows.h&gt;<br />int&nbsp;main(int&nbsp;argc,&nbsp;char**&nbsp;argv)<br /><span style="color:#000000;font-weight:400">{</span><br />ShellExecute(0,&quot;open&quot;,&quot;cmd&quot;,0,0,3);<br /><span style="color:#000000;font-weight:400">}</span></div></div><br />function <a href="https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea?redirectedfrom=MSDN" target="_blank">ShellExecute</a>(alias ShellExecuteA) called with these parameters <span style="text-decoration:underline;">will spawn a new command prompt</span> and will maximize the window<br />    Below we can see its syntax:<br />    <div class="codebox"><div class="codebox">HINSTANCE&nbsp;ShellExecuteA(<br />&nbsp;&nbsp;HWND&nbsp;&nbsp;&nbsp;hwnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//displaying&nbsp;a&nbsp;UI&nbsp;or&nbsp;error&nbsp;messages<br />&nbsp;&nbsp;LPCSTR&nbsp;lpOperation,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//specifies&nbsp;the&nbsp;action&nbsp;to&nbsp;be&nbsp;performed<br />&nbsp;&nbsp;LPCSTR&nbsp;lpFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//string&nbsp;that&nbsp;specifies&nbsp;the&nbsp;file&nbsp;or&nbsp;object&nbsp;to&nbsp;execute&nbsp;on&nbsp;which&nbsp;to&nbsp;execute&nbsp;the&nbsp;specified&nbsp;lpOperation<br />&nbsp;&nbsp;LPCSTR&nbsp;lpParameters,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//parameters&nbsp;to&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;application&nbsp;lpfile<br />&nbsp;&nbsp;LPCSTR&nbsp;lpDirectory,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*string&nbsp;that&nbsp;specifies&nbsp;the&nbsp;default&nbsp;(working)&nbsp;directory&nbsp;for&nbsp;the&nbsp;action;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;a&nbsp;relative&nbsp;path&nbsp;is&nbsp;provided&nbsp;at&nbsp;lpFile,&nbsp;do&nbsp;not&nbsp;use&nbsp;a&nbsp;relative&nbsp;path&nbsp;for&nbsp;lpDirectory&nbsp;*/<br />&nbsp;&nbsp;INT&nbsp;&nbsp;&nbsp;&nbsp;nShowCmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//specify&nbsp;how&nbsp;an&nbsp;application&nbsp;is&nbsp;to&nbsp;be&nbsp;displayed&nbsp;when&nbsp;it&nbsp;is&nbsp;opened<br />);</div></div><br /><br />2. <strong>Compile the C++(.cpp) file</strong><br /><div class="codebox"><div class="codebox">g++&nbsp;-m32&nbsp;c++.cpp&nbsp;-o&nbsp;c++.exe</div></div><br />or directly from Dev-C++ or others IDE<br /><br />3. <strong>Decompile EXE with Immunity Debugger</strong><br />We can decompile it also with <a href="Home--Penetration_Test_Methodology--System_Security_(Windows_&_Linux)--Assemblers,_Debuggers_and_Tools--Decompiler--objdump_(Dev-C++).html">objdump</a> but is very impractical. <br /><a href="file://C:/CherryTree/screenshots2/PTP-elearnsecurity/1. System Security/4 - Shellcoding/ShellExecute_decompiled.png"><img src="images/534-1.png" alt="images/534-1.png" /></a><br />The <span style="color:#ff8700;">parameters of the function are pushed in the reverse order</span>, in this way we will have the last parameter pushed(the first in C++ code) <span style="text-decoration:underline;">at the top of the </span><strong><span style="text-decoration:underline;">stack</span></strong><br /><a href=""><img src="images/534-2.png" alt="images/534-2.png" /></a><br /><br />4. <strong>Create the Shellcode</strong><br />    4.1 <strong>PUSH parameters of the function to the stack</strong><br />    The parameters have to be PUSHed in the <span style="text-decoration:underline;">reverse order</span> found in C++; <br />    ◇ PUSH opcode is <span style="color:#00ff79;">68 (\x68)</span> for word and dword<br />    ◇ PUSH opcode id <span style="color:#8eff00;">6A (\x6A)</span> for a byte(e.g.: integer,..)<br />        4.1.1 <strong>Translate Strings from Assembly to Opcode</strong><br />            4.1.1.1 <strong>Manually </strong> <br />           ◇ <span style="text-decoration:underline;">split</span> string ASCII representation into groups of 4 characters(4 bytes) since we will have to push them to the stack<br />           ◇ <span style="text-decoration:underline;">convert</span> the ASCII characters into hexadecimal values (online: <a href="http://www.asciitohex.com/">asciitohex</a>, <a href="http://www.rapidtables.com/convert/number/ascii-to-hex.htm">rapidtable</a>); before each hexadecimal value add the \x notation before each byte, \x in C/C++ indicates a hexadecimal character escape<br />           ◇ <span style="text-decoration:underline;">Terminate the string</span>(not the group of 4 characters) with \x00 otherwise the function parameter will load all the data in the stack (or until it find another \x00);<br />              ▪ if \x00 is not enter in the last group of character(it count as character) we have 2 possibilities:<br />                 - we can use the PUSH opcode 68 and create a new group of 4 character, put \x00 at the end and fill the remaining part with \x20 (hexadecimal value of the space character)<br />                    <span style="color:#a5452a;">example:</span> <code><span style="color:#00ff79;">\x68</span></code><code>\x20\x20\x20\x00</code><br />                 - we can use the PUSH opcode 6A and put directly \x00<br />                    <span style="color:#a5452a;">example:</span> <code><span style="color:#8eff00;">\x6A</span></code><code>\x00</code><br />            4.1.1.2 <strong>Automatically  with tools</strong><br />              ◇ online tools: <a href="https://defuse.ca/online-x86-assembler.htm#disassembly" target="_blank">defuse.ca</a><br />              ◇ offline tools: Metasm, Immunity...<br />              ◇ Immunity Debugger → double-click on a random instruction in the main panel and type the ASM code that we want to assemble in the pop-up window that appears<br />              <br />        4.1.2 <strong>If the function require a pointer to the string and not the string itself</strong><br />         ◇  We have to save a pointer to the string using a register. <br />            Because when we push a string to the stack <span style="color:#ff0000;">ESP</span> is automatically updated and point to our string; we can save the value of <span style="color:#ff0000;">ESP</span>(current stack position) into a <span style="color:#ff8700;">register</span>(such as EBX or ECX). To save the pointer of <span style="color:#ff0000;">ESP</span> into another <span style="color:#ff8700;">register</span> we can use an instruction right this <code>mov ebx, </code><code><span style="color:#ff0000;">esp</span></code><br />            <span style="color:#a5452a;">example:</span><br />            <div class="codebox"><div class="codebox">\x8B\xDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;mov&nbsp;ebx,&nbsp;esp</div></div><br />            To translate these operations we can use an online tool like: <a href="https://defuse.ca/online-x86-assembler.htm" target="_blank">https://defuse.ca/online-x86-assembler.htm</a><br />         ◇ If there are not other parameters to pass to the function we can PUSH the register<br />             <span style="color:#a5452a;">example:</span><br />            <div class="codebox"><div class="codebox">\x53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;PUSH&nbsp;EBX</div></div><br />            <br />        4.1.3 <strong>Pass integer values to the function</strong><br />        We have different ways to do it:<br />         ◇ PUSH it directly into the stack<br />            <span style="color:#a5452a;">example:</span><br />            <div class="codebox"><div class="codebox">\x6A\x05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;PUSH&nbsp;5</div></div><br />         ◇ move the integer into a register and then PUSH the register<br />            <span style="color:#a5452a;">example:</span><br />            <div class="codebox"><div class="codebox">\x33\xC0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;xor&nbsp;eax,&nbsp;eax<br />\x50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;PUSH&nbsp;EAX&nbsp;=&gt;&nbsp;pushes&nbsp;0</div></div><br />         ◇ zero out a register and then increment the register of n times (n is the value of the integer)<br />         <br />    4.2 <strong>Call the function</strong><br />      ◇ find the address of the function that we want call, example with <a href="ws_&_Linux)--Shellcoding--Manually_create_a_Shellcode_from_C++--Search_for_the_address_of_function_in_executable-dll_that_we_want_to_call.html">arwin</a><br />      ◇ move(MOV) the address value into a register and then CALL it<br />        <div class="codebox"><div class="codebox">\xB8\x78\x70\x30\x76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;MOV&nbsp;EAX,76307078&nbsp;-&nbsp;address&nbsp;of&nbsp;ShellExecuteA<br />\xff\xD0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;CALL&nbsp;EAX</div></div><br /><br />5. <strong>Test if the Shellcode works</strong><br />To test if the shellcode works we need to Compile the C++ file seen also here <br />Because ASLR is enabled(address randomization) for the library Shell32.dll the below code work only on the Windows 7 machine tested <br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;windows.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;needed&nbsp;to&nbsp;load&nbsp;Shell32.dll<br />char&nbsp;code[]&nbsp;=&nbsp;<br />&quot;\x68\x63\x6d\x64\x00&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;PUSH&nbsp;&quot;cmd&quot;&nbsp;-&nbsp;string&nbsp;already&nbsp;terminated<br />&quot;\x8B\xDC&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;MOV&nbsp;EBX,&nbsp;ESP;&nbsp;means&nbsp;copy&nbsp;the&nbsp;pointer&nbsp;to&nbsp;&quot;cmd&quot;&nbsp;in&nbsp;EBX<br />&quot;\x6A\x00&quot;&nbsp;					//&nbsp;PUSH&nbsp;the&nbsp;string&nbsp;terminator&nbsp;\x00&nbsp;for&nbsp;&quot;open&quot;<br />&quot;\x68\x6f\x70\x65\x6e&quot;&nbsp;		//&nbsp;PUSH&nbsp;&quot;open&quot;&nbsp;onto&nbsp;the&nbsp;stack<br />&quot;\x8B\xCC&quot;&nbsp;					//&nbsp;MOV&nbsp;ECX,&nbsp;ESP;&nbsp;means&nbsp;copy&nbsp;the&nbsp;pointer&nbsp;to&nbsp;&quot;open&quot;&nbsp;in&nbsp;ECX<br />&quot;\x6A\x03&quot;&nbsp;					//&nbsp;PUSH&nbsp;3:&nbsp;Push&nbsp;the&nbsp;last&nbsp;argument&nbsp;with&nbsp;value&nbsp;3&nbsp;or&nbsp;also&nbsp;called&nbsp;SW_SHOWMAXIMIZED<br />&quot;\x33\xC0&quot;&nbsp;					//&nbsp;xor&nbsp;eax,&nbsp;eax;&nbsp;zero&nbsp;out&nbsp;eax<br />&quot;\x50&quot;&nbsp;						//&nbsp;PUSH&nbsp;EAX:&nbsp;push&nbsp;second&nbsp;to&nbsp;last&nbsp;argument&nbsp;-&nbsp;0<br />&quot;\x50&quot;&nbsp;						//&nbsp;PUSH&nbsp;EAX:&nbsp;push&nbsp;third&nbsp;to&nbsp;last&nbsp;argument&nbsp;-&nbsp;0<br />&quot;\x53&quot;&nbsp;						//&nbsp;PUSH&nbsp;EBX:&nbsp;push&nbsp;pointer&nbsp;to&nbsp;string&nbsp;&#39;cmd&#39;<br />&quot;\x51&quot;&nbsp;						//&nbsp;PUSH&nbsp;ECX:&nbsp;push&nbsp;pointer&nbsp;to&nbsp;string&nbsp;&#39;open&#39;<br />&quot;\x50&quot;&nbsp;						//&nbsp;PUSH&nbsp;EAX:&nbsp;push&nbsp;the&nbsp;first&nbsp;argument&nbsp;-&nbsp;0<br />&quot;\xB8\x78\x70\x30\x76&quot;&nbsp;		//&nbsp;MOV&nbsp;EAX,76307078:&nbsp;move&nbsp;ShellExecuteA&nbsp;address&nbsp;into&nbsp;EAX<br />&quot;\xff\xD0&quot;&nbsp;					//&nbsp;CALL&nbsp;EAX:&nbsp;call&nbsp;the&nbsp;function&nbsp;ShellExecuteA<br />;&nbsp;							//&nbsp;Terminates&nbsp;the&nbsp;C&nbsp;instruction<br /><br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)&nbsp;<br /><span style="color:#000000;font-weight:400">{</span>&nbsp;<br />	LoadLibraryA(&quot;Shell32.dll&quot;);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;force&nbsp;the&nbsp;program&nbsp;to&nbsp;load&nbsp;Shell32.dll&nbsp;otherwhise&nbsp;<br />									//&nbsp;the&nbsp;shellcode&nbsp;will&nbsp;jump&nbsp;to&nbsp;an&nbsp;empty&nbsp;location&nbsp;and&nbsp;the&nbsp;shellcode&nbsp;will&nbsp;fail<br />	int&nbsp;(*func)();&nbsp;<br />	func&nbsp;=&nbsp;(int&nbsp;(*)())&nbsp;code;&nbsp;<br />	(int)(*func)();&nbsp;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />6. <strong>Debug the Shellcode</strong><br />If we want debug the program once we have compiled it we can open the .exe with Immunity Debugger and this is the Shellcode injected. <br />The behavior it&#39;s the same of the part of code debugged at the point &quot;3. Decompile EXE with Immunity Debugger&quot;<br /><a href=""><img src="images/534-3.png" alt="images/534-3.png" /></a><br /><br />Her in the stack we can see the pointers that contain the addresses that actually store the strings<br /><a href=""><img src="images/534-4.png" alt="images/534-4.png" /></a><br /><br /></div>
</body>
</html>
