<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>WAF bypass and filter tests</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>WAF bypass and filter tests</h1><br /><br />Majority of filters of a Web Application are blacklist
    rather than whitelist, which presents opportunities for evasion or bypass<br />The goal of this phase of our XSS
    fuzzing is to develop an understanding of the input filtering or output encoding performed by the
    application<br /><br /><strong>Why Websites use Filtering</strong><br />A filter means that probably the parameter
    we are testing is vulnerable to XSS! but the developer has created a filter to prevent any malicious HTML.<br />XSS
    is the easiest bug type to prevent against, so why are they creating a filter? And what else have they created
    filters around<br />If the<span style="text-decoration:underline;"> application performs any validation</span> or
    other processing on the submitted data before it is reflected, this will generally affect what kind of XSS payload
    is needed.<br />We need to test:<br /> ◇ tags<br /> ◇ events<br />Portswigger has built a XSS cheat sheet that can
    help in this process: <a
      href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet" target="_blank">https://portswigger.net/web-security/cross-site-scripting/cheat-sheet</a><br /><br /><br /><strong>DOM
      Event Handler Bypass: HTML Injection to Script Injection</strong><br />Because commonly filtered XSS input
    are:<br /> ◇ &lt;script&gt; tag<br /> ◇ angle brackets ‘&lt;‘ or ‘&gt;’<br />DOM event handlers can sometimes
    provide a simple bypass opportunity, depending on where our <a
      href="p_Pentest--Exploitation--Client-Side--Cross_Site_Scripting(XSS)--Identify_XSS_contexts--Determine_location_of_the_request_in_the_response.html">input
      ends up within the HTML (XSS injection Contexts)</a><br /><span
      style="color:#a5452a;">Example:</span><br />Because of maybe &lt;script&gt; tags are filtered out or encoded,
    maybe &lt;img&gt; and &lt;a&gt; are not<br />Let see how have scripting ability without the &lt;script&gt;
    tag<br /><span style="text-decoration:underline;">Instead of</span> <span
      style="color:#ff0000;">&lt;script&gt;alert(42)&lt;/script&gt;</span>, <br />we could inject: <span
      style="color:#ff0000;">&lt;img src=&quot;random&quot; onerror=alert(42)&gt;</span> the nonexistent image will
    cause the injected onerror event to be triggered<br /><br /><br /><strong>Browser could filter our XSS payloads
      (False Negatives</strong>)<br />NOTE: Unless the details of the penetration test specifically require considering
    potential victims’ browsers, this should be considered out of scope for a web application penetration
    test.<br />Regardless of the Web Application’s filtering or encoding, the browser could filter our XSS payloads. XSS
    payload execution depends on the particular browser that can render the content differently.<br />• Chrome has <a
      href="https://www.chromestatus.com/feature/5021976655560704" target="_blank">removed their XSS Auditor</a> from the release
    78<br /> ◇ on older version we can disable it with <br />
    <div class="codebox">
      <div class="codebox">root@kali:/#&nbsp;chromium-browser&nbsp;--disable-xss-auditor</div>
    </div><br />• Firefox has not, and <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=528661">will not implement
      X-XSS-Protection</a><br />• Edge has <a
      href="https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/" target="_blank">retired
      their XSS filter</a> from version 17<br /> <a href=""><img src="images/1580-1.png"
        alt="images/1580-1.png" /></a><br />If the XSS filter is available mean that the browser can put the HTTP
    <code>X-XSS-Protection</code> as response header. This is a feature of the Browser that stops pages from loading
    when they detect reflected cross-site scripting (XSS) attacks<br /> ◇ X-XSS-Protection: 0 → Disables XSS
    filtering.<br /> ◇ X-XSS-Protection: 1 → Enables XSS filtering. If a cross-site scripting attack is detected, the
    browser will sanitize the page (remove the unsafe parts).<br /> ◇ X-XSS-Protection: 1; mode=block → Enables XSS
    filtering. Rather than sanitizing the page, the browser will prevent rendering of the page if an attack is
    detected.<br /><br />Bibliography:<br />• Rodolfo Assis 2020 cheatsheet: <a
      href="https://it.b-ok.global/book/16086758/42740e" target="_blank">https://it.b-ok.global/book/16086758/42740e</a><br />
  </div>
</body>

</html>