<!doctype html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Case Study: Parity Wallet Attack</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>

<body>
  <div class='page'>
    <h1 class='title'>Case Study: Parity Wallet Attack</h1><br /><br /><br />One of the most famous attack using
    delegate calls is the <span style="text-decoration:underline;">Parity Wallet hack</span> which resulted in a
    multi-million-dollar losses.<br />The vulnerable Parity contract we are referencing is located at the following
    Contract address Location:<br /> <a
      href="https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code" target="_blank">https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code</a><br /><br /><br /><strong>
      <h3>Background</h3>
    </strong><br /><a href="https://parity.io/" target="_blank">Parity</a> is a client for the Ethereum Blockchain, it can be used as a
    wallet or an interface for Ethereum smart contracts.<br />This exploit only affects multisig wallets in Parity and
    not regular accounts.<br /><br /><strong>What’s a multisig wallet?</strong><br />Parity’s multisig Wallet is a smart
    contract which provides the functionality of multiple ownership ( owners need to sign transactions ) and wallet day
    limits.<br /><br /><strong>Use of libraries</strong><br />Essentially the parity wallet was a multi-signature wallet
    which was extremely lightweight and relied on functionality from a main library contract.<br />Using libraries is a
    way of saving costs as wallets will be deployed multiple times on the blockchain and the fee to deploy contracts is
    based on the size of the instructions used in the contract. Less instructions on a smaller lightweight wallet equals
    less overall transaction payments. <br />By deploying the main functionality within a callable library, the code
    only incurred a onetime fee for the larger codebase. Each additional deployed contract comes at a much smaller cost
    due to its reduced size of instructions. This is fantastic from both a cost savings and upgradeability perspective,
    depending how you deploy the functionality and how you handle access to libraries. <br /><br /><strong>Lack of
      authorization and check state</strong><br />But the Parity wallet had a few shortcomings due to a combination of
    public initialization functions that lacked a usage state and authorization issues. Authorization issues allowed
    direct calls after initial contract deployment and delegate calls allowed attackers to interact with initialization
    functions in the context of the calling contract. <br /><span style="text-decoration:underline;">Parity Issues that
      allowed an Attack</span>:<br /> ◇ An attack Vector into the library via the wallet (DelegateCall in a Fallback
    function)<br /> ◇ Initialization functions that didn’t check a wallets current initialization state<br /> ◇ Public
    functions without authorization<br /><br /><br /><br /> <br />Bibliography:<br />• <a
      href="https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/" target="_blank">https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/</a><br />•
    <a
      href="http://console-cowboys.blogspot.com/2020/10/smart-contract-hacking-chapter-7.html" target="_blank">http://console-cowboys.blogspot.com/2020/10/smart-contract-hacking-chapter-7.html</a>
  </div>
</body>

</html>